{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Preface","text":"<p>For Java developers, Micronaut is a relatedly new framework. It provides more concise APIs to building modern cloud-native applications. </p> <p>I have used Spring Boot in numerous real-world projects. In my opinion, there is no press when switching to Micronaut. When exploring the Micronaut features in this tutorial, I am trying to introduce them from the view of a Spring Boot developer.</p>"},{"location":"#audience","title":"Audience","text":"<p>I assume you are already a Java developer and know some knowledge of Spring framework and at least used one of the popular Dependency injection frameworks, eg. Spring, Guice, or Weld, or know well about the JSR 330 specification(aka Dependency Inject specification).</p> <p>I am trying to use the latest Java 17 language syntax in the sample codes. Please update yourself if you are using a lower-versioned Java. </p> <p>Besides Java, to demonstrate Micronaut polyglot feature, some example codes are written in Kotlin and Kotlin Coroutines, even Groovy and Scala in future.</p>"},{"location":"#sample-codes","title":"Sample Codes","text":"<p>All sample codes of this tutorial are available on Github. Get a copy of the source codes, and explore them yourself.</p> <p>In short, you can clone the project from Github via GIT command line.</p> <pre><code>$ git clone https://github.com/hantsy/micronaut-sandbox\n</code></pre>"},{"location":"#contribution","title":"Contribution","text":"<p>Any contributions are welcome. You can file an issue or send a PR on Github. If my work is helpful, please help me to spread it out to your circles or buy me a coffee.:)</p>"},{"location":"#about-me","title":"About Me","text":"<p>My name is Hantsy, an independent freelancer from China, I have over 20 years of software engineering experience. If you need some development and technical consulting service, please drop me an email, my email address is hantsy@gmail.com.</p> <p>Enjoy reading!</p>"},{"location":"gs/","title":"Getting Started","text":"<p>In this chapter, we will write some codes to explore the basic features. </p> <p>You will learn how to generate a project skeleton quickly from the online service Micronaut Launch or Micronaut CLI.</p> <p>Then we will create several small projects to demonstrate building RESTful APIs with Micronaut, in the samples, we will use varied combination of different languages and data access technologies.</p> <ul> <li>Java + Micronaut Data JPA</li> <li>Kotlin + Micronaut Data Jdbc</li> <li>Kotlin Coroutine + Micronaut Data R2dbc</li> <li>Java + Micronaut Mongo Reactive</li> </ul>"},{"location":"gs/build/","title":"Building and Running Application","text":"<p>There are several approaches to building and running the application.</p>"},{"location":"gs/build/#using-ide","title":"Using IDE","text":"<p>In an IDE, such as IDEA, it is easy to use the IDE built-in tools to build or rebuild the whole project. Most of modern IDEs include incremental building for code changes automaticially.</p> <p>To run the application, open the entry class <code>Application</code>, click and run it directly like running a  Java application.</p>"},{"location":"gs/build/#using-command-line","title":"Using Command Line","text":"<p>If it is a Maven project, open terminal and run <code>mvn clean package</code> in the project root folder to build the application into a jar archive.</p> <pre><code>$ mvn clean package\n</code></pre> <p>Then run the build application.</p> <pre><code>$ java -jar target/demo.jar\n</code></pre> <p>If you prefer Gradle as the build tools, use the following commands instead.</p> <pre><code>$ ./gradle build\n$ java -jar build/demo.jar\n</code></pre>"},{"location":"gs/build/#setup-database","title":"Setup Database","text":"<p>In the root folder of the sample codes repository, there is a prepared Docker Compose file, which is used to serve required external service when building and running the sample applications, including Postgres, Mongo, etc.</p> <p>For example, run the following command to bootstrap a Postgres database instance in Docker.</p> <pre><code>$ docker compose up postgres\n</code></pre>"},{"location":"gs/di/","title":"Understanding Dependency Injection in Micronaut","text":"<p>Micronaut provides a JSR330(aka <code>@Inject</code> specification) compatiable IOC container.</p> <p>JSR330 was led by SpringSource(now VMware) and Google. </p> <p>Spring also has built-in JSR330 support, but it is not activated by default. You should add <code>inject</code> artifact in your project dependencies to enable it.</p>"},{"location":"gs/di/#declare-beans","title":"Declare Beans","text":"<p>To declare an injectable bean in Micronaut applications,  add a <code>@Singleton</code> annotation to your class. Thus the bean is available in the Micronaut IOC container.</p> <pre><code>@Singleton\nclass OrderService{}\n</code></pre> <p>To use it in other beans, inject it with a <code>@Inejct</code> or use constructor injection.</p> <pre><code>@Controller\nclass OrderController{\n    @Inject OrderService orderService;\n    //....\n}\n\n// constructor injection.\n@Controller\nclass OrderController{\n    private final OrderService orderService;\n\n    public OrderController( OrderService orderService){\n        this.orderService = orderService;\n    }\n}\n</code></pre> <p>Micronaut also provides an <code>ApplicationContext</code> which allows you to fetch beans manually.</p> <pre><code>var context = ApplicationContext.run();\nvar orderService = context.getBean(OrderService.class);\n</code></pre> <p>Or register your POJOs as beans.</p> <pre><code>var context = ApplicationContext.builder()\n        .build();\ncontext.registerSingleton(new FooBar());\ncontext.start();\n\nvar fooBar = context.getBean(FooBar.class);\n</code></pre> <p>A <code>@Singleton</code> bean means there is only one instance in the application at runtime.  <code>@Prototype</code> ensures that it produces a new instance for every injection.</p> <pre><code>@Prototype\nclass UserModel {\n}\n\nvar context = ApplicationContext.run();\nvar model = context.getBean(UserModel.class);\nvar model2 = context.getBean(UserModel.class);\n\nassertThat(model == model2).isFalse();\n</code></pre> <p>Like Spring Boot's <code>Configuration</code>, Micronaut provides a <code>@Factory</code> to group simple beans in a central configuration. For example.</p> <pre><code>@Factory\nclass MyConfig{\n\n    @Bean\n    public Foo foo(){}\n\n    @Bean\n    public Bar bar(){}\n}\n</code></pre>"},{"location":"gs/di/#build-time-aot","title":"Build-time AOT","text":"<p>When building the application, explore the project build/classes folder, there are some extra classes generated at compile time.</p> <p>For example, when the above <code>UserModel</code> is compiled, there are two extra classes generated: <code>$UserModel$Definition</code> and <code>$UserModel$Definition$Reference</code>. These two classes incldue all metadata info of defining a bean and injecting a bean.</p> <p>Open them in your IDE and have a look at the source codes that are already anti-compiled to Java.</p> <pre><code>@Generated\nclass $UserModel$Definition extends AbstractInitializableBeanDefinition&lt;UserModel&gt; implements BeanFactory&lt;UserModel&gt; {\n    private static final MethodOrFieldReference $CONSTRUCTOR = new MethodReference(UserModel.class, \"&lt;init&gt;\", (Argument[])null, (AnnotationMetadata)null, false);\n\n    public UserModel build(BeanResolutionContext var1, BeanContext var2, BeanDefinition var3) {\n        UserModel var4 = new UserModel();\n        var4 = (UserModel)this.injectBean(var1, var2, var4);\n        return var4;\n    }\n\n    protected Object injectBean(BeanResolutionContext var1, BeanContext var2, Object var3) {\n        UserModel var4 = (UserModel)var3;\n        return super.injectBean(var1, var2, var3);\n    }\n\n    public $UserModel$Definition() {\n        this(UserModel.class, $CONSTRUCTOR);\n    }\n\n    protected $UserModel$Definition(Class var1, MethodOrFieldReference var2) {\n        super(var1, var2, $UserModel$Definition$Reference.$ANNOTATION_METADATA, (MethodReference[])null, (FieldReference[])null, (ExecutableMethodsDefinition)null, (Map)null, Optional.of(\"io.micronaut.context.annotation.Prototype\"), false, false, false, false, false, false, false, false);\n    }\n}\n\n@Generated(\n    service = \"io.micronaut.inject.BeanDefinitionReference\"\n)\npublic final class $UserModel$Definition$Reference extends AbstractInitializableBeanDefinitionReference {\n    public static final AnnotationMetadata $ANNOTATION_METADATA;\n\n    static {\n        DefaultAnnotationMetadata.registerAnnotationDefaults($micronaut_load_class_value_0(), AnnotationUtil.mapOf(\"typed\", ArrayUtils.EMPTY_OBJECT_ARRAY));\n        $ANNOTATION_METADATA = new DefaultAnnotationMetadata(AnnotationUtil.internMapOf(\"io.micronaut.context.annotation.Prototype\", Collections.EMPTY_MAP), AnnotationUtil.mapOf(\"io.micronaut.context.annotation.Bean\", Collections.EMPTY_MAP, \"javax.inject.Scope\", Collections.EMPTY_MAP), AnnotationUtil.mapOf(\"io.micronaut.context.annotation.Bean\", Collections.EMPTY_MAP, \"javax.inject.Scope\", Collections.EMPTY_MAP), AnnotationUtil.internMapOf(\"io.micronaut.context.annotation.Prototype\", Collections.EMPTY_MAP), AnnotationUtil.mapOf(\"io.micronaut.context.annotation.Bean\", AnnotationUtil.internListOf(new Object[]{\"io.micronaut.context.annotation.Prototype\"}), \"javax.inject.Scope\", AnnotationUtil.internListOf(new Object[]{\"io.micronaut.context.annotation.Prototype\"})), false, true);\n    }\n\n    public $UserModel$Definition$Reference() {\n        super(\"com.example.UserModel\", \"com.example.$UserModel$Definition\", $ANNOTATION_METADATA, false, false, false, false, false, false, false, false);\n    }\n\n    public BeanDefinition load() {\n        return new Definition();\n    }\n\n    public Class getBeanDefinitionType() {\n        return Definition.class;\n    }\n\n    public Class getBeanType() {\n        return UserModel.class;\n    }\n}\n</code></pre> <p>At runtime, Micornaut uses these two classes to define a bean named <code>UserModel</code> in the <code>prototype</code> scope and make it available in the <code>ApplicationContext</code>. When other beans inject it, Micronaut uses them to produce a new instance for use. In the whole progress, it does not invoke the Java reflection APIs to get the metadata info of <code>UserModel</code>.</p>"},{"location":"gs/gen/","title":"Generate a Project Skeleton","text":"<p>Similar to Spring Initializr, Micronaut provides an online service named Launch to generate a project skeleton for you.</p> <p>Alternatively, Micronaut provides a command line. You can use it to generate a new project from the existing templates.</p>"},{"location":"gs/gen/#micronaut-launch","title":"Micronaut Launch","text":"<p>Open your browser, go to Micronaut Launch, you will see the following screen.</p> <p></p> <p>In the Application Type field, there are several options available in the dropdown menu, including Micronaut Application, Command Line Application, gRPC Application, Function Application for serverless, Message-Driven Application. For different purposes, you can choose one to generate the project skeleton. If you want to create a general web application, a RESTful API backend application, or a Microservice component, use the default Micronaut Application.</p> <p>In the Java version field, it is highly recommended to choose the latest LTS version 17.  </p> <p>If you want to customize the application name (it is also the project artifact id) and base package name, alter the value in the Name and Package Name fields.</p> <p>Next, select the Micronaut Version(for new project, the latest stable version is recommended) and your favorite programming Language(Java, Kotlin, Groovy), Build Tools(Maven, Gradle, Gradle with Kotlin Script) and Test framework(JUnit, Kotest, Spock).</p> <p>Click the Features button, it will popup a new window. In the popup window, it lists all Micronaut integrated libraries/frameworks. Filter and select those you want to use to build the application. </p> <p>Before downloading the generated archive, click the PREVIEW button to preview the file structure in a popup window.</p> <p>Finally, hit the GENERATE PROJECT button to produce the project files into an archive for download.</p> <p>Extract the project files from the download archive into your local disk, and import the files into your IDE.  </p>"},{"location":"gs/gen/#micronaut-cli","title":"Micronaut CLI","text":"<p>You can also create a Micronaut project using Micronaut CLI, check Micronaut documentation for details.</p> <p>Under Windows system, to get Linux bash-like command experience, you can install Cygwin or enable WSL(Windows subsystem for Linux).</p> <p>Firstly install SDKMan, which is a popular software management tool for developers. </p> <p>Open your terminal, and run the following command to install SDKMan automatically.</p> <pre><code>$ curl -s \"https://get.sdkman.io\" | bash\n</code></pre> <p>After it is completed, run this command to initialize SDKMan configuration.</p> <pre><code>$ source \"$HOME/.sdkman/bin/sdkman-init.sh\"\n</code></pre> <p>Verify the SDKMan installation.</p> <pre><code>$ sdk version\n\nSDKMAN 5.12.4\n</code></pre> <p>Next, install Micronaut CLI from the official SDKMan reposiory.</p> <pre><code>$ sdk install micronaut\n</code></pre> <p>After it is done, verify the installation.</p> <pre><code>$ mn -V\nMicronaut Version: 3.1.0\n</code></pre> <p>Type <code>mn --help</code> command in the terminal to get all available options.</p> <pre><code>$mn --help\nUsage: mn [-hvVx] [COMMAND]\nMicronaut CLI command line interface for generating projects and services.\nApplication generation commands are:\n\n*  create-app NAME\n*  create-cli-app NAME\n*  create-function-app NAME\n*  create-grpc-app NAME\n*  create-messaging-app NAME\n\nOptions:\n  -h, --help         Show this help message and exit.\n  -v, --verbose      Create verbose output.\n  -V, --version      Print version information and exit.\n  -x, --stacktrace   Show full stack trace when exceptions occur.\n\nCommands:\n  create-app            Creates an application\n  create-cli-app        Creates a CLI application\n  create-function-app   Creates a Cloud Function\n  create-grpc-app       Creates a gRPC application\n  create-messaging-app  Creates a messaging application\n\n</code></pre> <p>The Commands options are similar to the Application Type options in the Micronaut Lauch page.</p> <p>Try to create a new project using the <code>mn</code> command.</p> <pre><code>$ mn create-app demo -b gradle -f lombok,postgres,data-jpa,hibernate-jpa,testcontainers -l java -t=junit\n\n| Application created at C:\\tools\\cygwin\\home\\hantsy\\demo\n</code></pre> <p>The project files are generated into the demo folder under current path. The file structure is similar to the one generated by the Micronaut Launch page.</p> <p>You can use <code>mn create-app --help</code> to get the option details of the <code>create-app</code> command.</p>"},{"location":"gs/gen/#exploring-project-structure","title":"Exploring project structure","text":"<p>Let's have a look at the files in the project.</p> <pre><code>.\n\u251c\u2500\u2500 build.gradle\n\u251c\u2500\u2500 gradle\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 wrapper\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 gradle-wrapper.jar\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 gradle-wrapper.properties\n\u251c\u2500\u2500 gradle.properties\n\u251c\u2500\u2500 gradlew\n\u251c\u2500\u2500 gradlew.bat\n\u251c\u2500\u2500 micronaut-cli.yml\n\u251c\u2500\u2500 settings.gradle\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 main\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 java\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 com\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 example\n    \u2502\u00a0\u00a0 \u2502\u00a0\u00a0         \u2514\u2500\u2500 Application.java\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 resources\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 application.yml\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 logback.xml\n    \u2514\u2500\u2500 test\n        \u251c\u2500\u2500 java\n        \u2502\u00a0\u00a0 \u2514\u2500\u2500 com\n        \u2502\u00a0\u00a0     \u2514\u2500\u2500 example\n        \u2502\u00a0\u00a0         \u2514\u2500\u2500 DemoTest.java\n        \u2514\u2500\u2500 resources\n            \u251c\u2500\u2500 application-test.yml\n            \u2514\u2500\u2500 logback-test.xml\n</code></pre> <p>Besides Gradle build scripts related resources, it is similar to the Spring Boot project structure. </p> <ul> <li>The <code>Application</code> is the entry class of the application.</li> <li>The src/main/resources/application.yml is the application configuration.</li> <li>The src/main/resources/logback.xml  is logging configuration, by default Micronaut uses Logback as logging framework.</li> <li>The <code>DemoTest</code> is an test example of using <code>@MicronautTest</code>. </li> <li>Under the src/test/resources folder, there are some configuration resources for testing.</li> </ul> <p>Let's have a look at build.gradle.</p> <p>It uses <code>com.github.johnrengelman.shadow</code> to package the application into a jar archive.</p> <p>The <code>io.micronaut.application</code> plugin handles the dependency injection at compile time via Java Compiler Annotation Processors. This plugin also includes other tasks, such building application into Docker image and GraalVM native executable binary.</p>"},{"location":"gs/gs-rest/","title":"Building RESTful API with Micronaut Data JPA","text":"<p>In this section, we are building a RESTful API backend application with Micronaut Data JPA. If you have some experience with Spring Boot and Spring Data JPA, it is easy to update yourself to use Micronaut to archive the same purpose.</p>"},{"location":"gs/gs-rest/#preparing-project-skeleton","title":"Preparing Project Skeleton","text":"<p>Follow Generating Project Skeleton guide and generate a new project skeleton.</p>"},{"location":"gs/gs-rest/#generating-project","title":"Generating Project","text":"<p>Open your browser and navigate to Micronaut Launch, fill the following fields in the Micronaut Launch page, leave other as it is.</p> <ul> <li>Java version:  17</li> <li>Language: Java </li> <li>Build tool: Gradle</li> <li>Test framework: Junit</li> <li>Included Features: lombok, data hibernate jpa, assertj, postgres, testcontainers etc.</li> </ul> <p>Import the generated project into your IDE.</p>"},{"location":"gs/gs-rest/#configuring-database","title":"Configuring Database","text":"<p>In this project, we are using Postgres as a database. You can download a copy of Postgres and install it in your local system, then create a new database to serve the application.</p> <p>Open src/main/resources/application.yml, there is a  default data source  is configured by default.</p> <p>Change the properties according to your environment.</p> <pre><code>datasources:\n  default:\n    url: jdbc:postgresql://localhost:5432/blogdb\n    driverClassName: org.postgresql.Driver\n    username: user\n    password: password\n    schema-generate: CREATE_DROP\n    dialect: POSTGRES\njpa.default.properties.hibernate.hbm2ddl.auto: update\n</code></pre> <p>Alternatively, you can serve a Postgres database in Docker quickly. </p>"},{"location":"gs/gs-rest/#serving-postgres-database-in-docker","title":"Serving  Postgres Database in Docker","text":"<p>Create a docker-compose.yml file, and define a postgres service as the following.</p> <pre><code>version: '3.7' # specify docker-compose version\n\nservices:\n  postgres:\n    image: postgres\n    ports:\n      - \"5432:5432\"\n    restart: always\n    environment:\n      POSTGRES_PASSWORD: password\n      POSTGRES_DB: blogdb\n      POSTGRES_USER: user\n    volumes:\n      - ./data:/var/lib/postgresql\n      - ./pg-initdb.d:/docker-entrypoint-initdb.d\n</code></pre> <p>Then start the Postgres database instance in the Docker container.</p> <pre><code>docker compose up postgres\n</code></pre> <p>Wait for a while, it will prepare a Postgres database from Docker image and start it.</p>"},{"location":"gs/gs-rest/#data-accessing-using-micronaut-data-jpa","title":"Data Accessing using Micronaut Data JPA","text":"<p>When generating the project, we have add a data-jpa feature into the project dependencies, which enables Micronaut Data JPA support. </p> <p>Similar to Spring Data architecture,  Micronaut Data also provides a common abstraction for the basic data operations, For example, there is a <code>GenericRepository</code> interface to indicate it is a  <code>Repository</code> for JPA entities,  and its sub interfaces, such as <code>CrudRepository</code> and <code>PagableRepsoitory</code> includes more operations, such as save,  retrieve, update, delete, and bulk updates, and return pageable results for large amount of results. </p> <p>Micronaut Data JPA has similar APIs with Spring Data JPA, it also contains a pragmatic criteria builder to execute query via custom <code>Specificaiton</code>.</p> <p>Currently, Micronaut Data project only supports relational databases, it includes 3 modules: Data JPA, Data JDBC, Data R2DBC,  read the official documentation for more details.</p> <p>In this post, we focus on the Micronaut Data JPA.</p> <p>Next, we will create a JPA entity and create a Repository for the entity, then create a  Controller to produce RESTful API endpoints for it.</p>"},{"location":"gs/gs-rest/#creating-jpa-entity","title":"Creating  JPA Entity","text":"<p>I have used a simple blog application in the past years to demonstrate different frameworks. In this post, I will reuse the blog application concept.  </p> <p>It includes two JPA entities, <code>Post</code> and <code>Comment</code>, it is a one-to-many relation.</p> <p>Firstly let's have a look at the <code>Post</code>  entity class.</p> <pre><code>@Getter\n@Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\n@Entity\n@Table(name = \"posts\")\npublic class Post implements Serializable {\n\n    @Id\n    @GeneratedValue(generator = \"uuid\")\n    @GenericGenerator(name = \"uuid\", strategy = \"uuid2\")\n    UUID id;\n    String title;\n    String content;\n\n    @Builder.Default\n    Status status = Status.DRAFT;\n\n    @Builder.Default\n    LocalDateTime createdAt = LocalDateTime.now();\n\n    @OneToMany(cascade = {CascadeType.ALL}, orphanRemoval = true, mappedBy = \"post\")\n    @Builder.Default\n    @OrderColumn(name = \"comment_idx\")\n    List&lt;Comment&gt; comments = new ArrayList&lt;&gt;();\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Post post = (Post) o;\n        return getTitle().equals(post.getTitle());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(getTitle());\n    }\n\n    @Override\n    public String toString() {\n        return \"Post{\" +\n                \"id=\" + id +\n                \", title='\" + title + '\\'' +\n                \", content='\" + content + '\\'' +\n                \", status=\" + status +\n                \", createdAt=\" + createdAt +\n                '}';\n    }\n}\n</code></pre> <p>A JPA entity should be annotated with an  <code>@Entity</code> annotation,  optionally adding a <code>@Table</code> to specify the table metadata.</p> <p>An entity should include a none-arguments constructor. </p> <p>An entity should have an identifier field with an <code>@Id</code> annotation. To assign a value to the id field automatically, you can select a strategy type by specifying the <code>strategy</code> attribute of the <code>@GgeneratedValue</code> annotation,  it could be <code>AUTO</code>, <code>IDENTITY</code>, <code>SEQUENCE</code> and <code>TABLE</code>, else you can define your own generator by setting the value of <code>generator</code> attribute. In the above <code>Post</code> entity, we use the Hibernate built-in <code>uuid2</code> strategy to generate a UUID value and assign it to the id field before persisting.</p> <p>With the annotations from the Lombok project, eg. <code>@Getter</code>, <code>@Setter</code>, <code>@NoArgsConstructor</code>, <code>@AllArgsConstructor</code> and <code>@Builder</code>, it helps you to erase the tedious methods for getting and setting the Java Bean properties,  and keep your codes clean. When building the project, Lombok annotation processor will participate into the compiling progress and generate getters and setters, varied constructors, and a builder class used to create an entity.</p> <p>Use IDE to generate <code>equals</code> and <code>hasCode</code> according to the business requirements. </p> <p>Be careful of using Lombok @Data to generate all facilities, especially in the entity in an inheritance structure or containing custom <code>equals</code> and <code>hasCode</code>  to identify an entity.</p> <p>Similar to the <code>Post</code> entity, create another entity named  <code>Comment</code>.</p> <pre><code>// Comment entity \n@Getter\n@Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\n@Entity\n@Table(name = \"comments\")\npublic class Comment implements Serializable {\n\n    @Id\n    @GeneratedValue(generator = \"uuid\")\n    @GenericGenerator(name = \"uuid\", strategy = \"uuid2\")\n    private UUID id;\n\n    @ManyToOne\n    @JoinColumn(name = \"post_id\")\n    private Post post;\n\n    private String content;\n\n    @Builder.Default\n    @Column(name = \"created_at\")\n    private LocalDateTime createdAt = LocalDateTime.now();\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Comment comment = (Comment) o;\n        return getContent().equals(comment.getContent());\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(getContent());\n    }\n\n    @Override\n    public String toString() {\n        return \"Comment{\" +\n                \"id=\" + id +\n                \", content='\" + content + '\\'' +\n                \", createdAt=\" + createdAt +\n                '}';\n    }\n}\n\n</code></pre> <p>The <code>Post</code> and <code>Comment</code> association is a simple bi-direction one-to-many relation. </p> <p>On the one side, aka  in<code>Post</code> entity,  a <code>@OneToMany</code> annotation is added to the comments which is a <code>List</code>,  the <code>cascade</code> attribute defines the behiavor to process the many side when performing a persist, merge, delete operation on  the one side, here we use <code>ALL</code> to setup all cascade rules will be applied.  The  <code>orphanRemoval=true</code> setting tells the persistence context to clear the <code>Comment</code> orphans when deleting a <code>Post</code> . The <code>@OrderColumn</code> will persist the inserted position of comments.  On the many side aka in the <code>Comment</code> entity, a <code>@ManyToOne</code> annotation is added on the <code>post</code> field. The <code>@JoinColumn</code> set the column which stores the foreign key constraints by the <code>Post</code> id.</p> <p>Besides one-to-many relation (<code>@OneToMany</code>and <code>@ManyToOne</code>), JPA specification includes two other relations, aka one-to-one (<code>@OneToOne</code>)  and many-to-many (<code>@ManyToMany</code>).</p> <p>We've just demonstrated a simple entity association case here, it is a bi-direction one-to-many relation.  Please note, one-to-one, one-to-many, and many-to-many can be set as single direction,  and you can use a  secondary table as connecting table in the one-to-one and one-to-many relations.</p> <p>We can not cover every details of JPA specifiction here. If you are new to JPA, Java persistence with Hibernate is a good book to start your  JPA journey.</p>"},{"location":"gs/gs-rest/#creating-repository","title":"Creating Repository","text":"<p>Create a <code>Repository</code> for the <code>Post</code> entity.</p> <pre><code>@Repository\npublic interface PostRepository extends JpaRepository&lt;Post, UUID&gt;{\n\n}\n</code></pre> <p>The <code>JpaRepository</code> overrides some existing methods in the parent <code>CrudRepository</code>and <code>PageableRepository</code>, and adds some JPA-specific methods, such as <code>flush</code> used to flush the persistence context by force.</p> <p>Note, in Micronaut Data, a Repository bean must be annotated with a <code>@Repository</code> annotation. In a multi-datasource environment, you can specify the datasource identifier name to ensure this repository uses the certain DataSource to connect to the database. </p> <p>For example, <code>@Repository(\"orders\")</code> to connect the orders datasource defined in the application.yml configuration.</p> <pre><code>datasources:\n  orders:\n    ....\n</code></pre> <p>Similarly, create a <code>Repository</code> for the <code>Comment</code> entity.</p> <pre><code>@Repository\npublic interface CommentRepository extends JpaRepository&lt;Comment, UUID&gt; {\n\n    List&lt;Comment&gt; findByPost(Post post);\n}\n</code></pre> <p>The <code>findByPost</code> is used to filter comments by a specific post argument. Similar to Spring Data JPA,  Micronaut Data support fluent query methods derived from property expression.</p> <p>Similar to Spring Data, Micronaut Data provides pagination for a long query result, the <code>findAll</code> accepts a <code>Pageable</code> parameter and returns a <code>Page</code> result.</p> <p>Micronaut Data also includes a <code>Specification</code>  to adopt JPA Criteria APIs for the complex type-safe query.</p>"},{"location":"gs/gs-rest/#query-by-specification","title":"Query by Specification","text":"<p>Change <code>PostRepository</code>  , add <code>JpaSpecificationExecutor&lt;Post&gt;</code> to extends list.</p> <pre><code>@Repository\npublic interface PostRepository extends JpaRepository&lt;Post, UUID&gt;, JpaSpecificationExecutor&lt;Post&gt; {\n\n}\n</code></pre> <p>The <code>JpaSpecificationExecutor</code> provides extra methods to accept a <code>Specification</code> as parameters.</p> <p>Create a specific <code>PostSpecifications</code> to group all specifications for querying posts. Currently, only add one for query by keyword and status.</p> <pre><code>public class PostSpecifications {\n    private PostSpecifications(){\n        // forbid to instantiate\n    }\n\n    public static Specification&lt;Post&gt; filterByKeywordAndStatus(\n            final String keyword,\n            final Status status\n    ) {\n        return (Root&lt;Post&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) -&gt; {\n            List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();\n            if (StringUtils.hasText(keyword)) {\n                predicates.add(\n                        cb.or(\n                                cb.like(root.get(Post_.title), \"%\" + keyword + \"%\"),\n                                cb.like(root.get(Post_.content), \"%\" + keyword + \"%\")\n                        )\n                );\n            }\n\n            if (status != null) {\n                predicates.add(cb.equal(root.get(Post_.status), status));\n            }\n\n            return cb.and(predicates.toArray(new Predicate[0]));\n        };\n    }\n}\n</code></pre> <p>The <code>filterByKeywordAndStatus</code> specification provides optional keyword and status to filter the posts.  The <code>Post_</code> is a metadata class generated by Hibernate metadata generating tools.  </p> <p>Add the following <code>annotationProcessor</code> in the project dependencies.</p> <pre><code>annotationProcessor('org.hibernate:hibernate-jpamodelgen:5.6.5.Final')\n</code></pre> <p>For those who are familiar with JPA <code>EntityManager</code> and prefer to use literal query string to handle complex queries,  In Micronaut Data, it is easy to use them in the Repository directly.</p>"},{"location":"gs/gs-rest/#custom-query-with-entitymanager","title":"Custom Query with EntityManager","text":"<p>Change the Repository interface to an abstract class,  and inject an <code>EntityManager</code>,  then you can use it freely in your custom methods.</p> <pre><code>@Repository()\n@RequiredArgsConstructor\npublic abstract class PostRepository implements JpaRepository&lt;Post, UUID&gt;, JpaSpecificationExecutor&lt;Post&gt; {\n    private final EntityManager entityManager;\n\n    public List&lt;Post&gt; findAllByTitleContains(String title) {\n        return entityManager.createQuery(\"FROM Post AS p WHERE p.title like :title\", Post.class)\n                .setParameter(\"title\", \"%\" + title + \"%\")\n                .getResultList();\n    }\n}\n</code></pre> <p>In the above <code>findAllByTitleContains</code> method, it uses <code>EntityManager</code> to execute a custom literal query.</p> <p>In contrast, to use <code>EntityManager</code> in your custom queries,  in Spring Data JPA, you need to create a <code>PostRepositoryCustom</code> interface and a <code>PostRepositoryImpl</code> implementation class. Micronaut Data simplifies the work.</p>"},{"location":"gs/gs-rest/#initializing-sample-data","title":"Initializing Sample Data","text":"<p>Add a <code>DataInitializer</code> bean to initialize some sample data.</p> <pre><code>@Singleton\n@RequiredArgsConstructor\n@Slf4j\npublic class DataInitializer implements ApplicationEventListener&lt;ApplicationStartupEvent&gt; {\n    private final PostRepository posts;\n\n    private final TransactionOperations&lt;?&gt; tx;\n\n    @Override\n    public void onApplicationEvent(ApplicationStartupEvent event) {\n        log.info(\"initializing sample data...\");\n        var data = List.of(Post.builder().title(\"Getting started wit Micronaut\").content(\"test\").build(),\n                Post.builder().title(\"Getting started wit Micronaut: part 2\").content(\"test\").build());\n        tx.executeWrite(status -&gt; {\n            this.posts.deleteAll();\n            this.posts.saveAll(data);\n            return null;\n        });\n        tx.executeRead(status -&gt; {\n            this.posts.findAll().forEach(p -&gt; log.info(\"saved post: {}\", p));\n            return null;\n        });\n        log.info(\"data initialization is done...\");\n    }\n}\n</code></pre> <p>In the above codes, use <code>TransactionOperations</code> to wrap a series of operations into a transaction to ensure it happens before the successor operations.</p>"},{"location":"gs/gs-rest/#exposing-restful-api","title":"Exposing RESTful API","text":"<p>Following the REST conventions and Richardson Mature Model, we design a series of HTTP API endpoints that satisfies the  Richardson Mature Model Level 2.</p> URI HTTP Method Description /posts GET Get all posts /posts/{id} GET Get a single Post, if not found return 404 status code. /posts POST Create a new Post, if successful, return 201 and add newly-created Post URI to the response <code>Location</code> header /posts/{id} PUT Update the existing Post, return 204. If not found return 404 /posts/{id} DELETE Delete the existing Post, return 204. If not found return 404 /posts/{id}/comments GET Get all comments of the specified Post. ... <p>Similar to Spring WebMVC,  Micronaut uses a <code>Controller</code> to expose Restful APIs. </p>"},{"location":"gs/gs-rest/#creating-controller","title":"Creating Controller","text":"<p>Create a controller to produce RESTful API.</p> <pre><code>@Controller(\"/posts\")\n@RequiredArgsConstructor(onConstructor_ = {@Inject})\n@Validated\npublic class PostController {\n    private final PostRepository posts;\n    private final CommentRepository comments;\n\n    @Get(uri = \"/\", produces = MediaType.APPLICATION_JSON)\n    public HttpResponse&lt;List&lt;PostSummaryDto&gt;&gt; getAll() {\n        var body = posts.findAll()\n                .stream()\n                .map(p -&gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt()))\n                .toList();\n        return ok(body);\n    }\n\n    @Get(uri = \"/{id}\", produces = MediaType.APPLICATION_JSON)\n    public HttpResponse&lt;?&gt; getById(@PathVariable UUID id) {\n        return posts.findById(id)\n                .map(p -&gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt())))\n                //.orElseThrow(() -&gt; new PostNotFoundException(id));\n        .orElseGet(HttpResponse::notFound);\n    }\n}\n</code></pre> <p>Usually, a controller is annotated with <code>@Controller</code>, you can set a base <code>uri</code> that applies to all methods. </p> <p>Note,  There is no <code>@RestController</code> in Micronaut.</p> <p>The <code>@Get</code>, <code>@Post</code>,<code>@Put</code>, <code>@Delete</code> annotations are used to handle varied HTTP methods, it is similar to Spring's <code>@GetMapping</code>, <code>@PostMapping</code>, etc.  </p> <p>You can set media types using consumes or produces  attributes in these annotations to limit the request and response content type, or use extra standalone annotations <code>@Consumes</code> and <code>@Produces</code> on the methods.</p> <p>In the <code>PostController</code> , we have two methods.  The <code>getAll</code> method serves the /posts endpoint, and the <code>getById(id)</code> serves the /posts/{id} endpoint.</p>"},{"location":"gs/gs-rest/#testing-endpoints-using-curl","title":"Testing Endpoints using cURL","text":"<p>Startup the application via Gradle command.</p> <pre><code>./gradlew run\n</code></pre> <p>Do not forget to start up Postgres database firstly.</p> <p>Open a terminal,  use <code>curl</code> command to test the <code>/posts</code> endpoint.</p> <pre><code>curl http://localhost:8080/posts\n[ {\n  \"id\" : \"b6fb90ab-2719-498e-a5fd-93d0c7669fdf\",\n  \"title\" : \"Getting started wit Micronaut\",\n  \"createdAt\" : \"2021-10-14T22:00:28.80933\"\n}, {\n  \"id\" : \"8c6147ea-8de4-473f-b97d-e211c8e43bac\",\n  \"title\" : \"Getting started wit Micronaut: part 2\",\n  \"createdAt\" : \"2021-10-14T22:00:28.80933\"\n} ]\n</code></pre> <pre><code>curl http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf\n {\n  \"id\" : \"b6fb90ab-2719-498e-a5fd-93d0c7669fdf\",\n  \"title\" : \"Getting started wit Micronaut\",\n  \"content\": \"test\",\n  \"createdAt\" : \"2021-10-14T22:00:28.80933\"\n}\n</code></pre> <p>Micronaut CLI provides commands to generate skeleton for controller, repository, bean, test, etc.  Run <code>mn --help</code> in the project root folder to get all available commands.</p>"},{"location":"gs/gs-rest/#handling-exception","title":"Handling Exception","text":"<p>In the above <code>PostController</code>, if there is no posts found for the given post id, it returns a 404 HTTP status directly. In a real-world application, we can use a custom exception to envelope the exception case. </p> <p>Like Spring WebMVC, Micronaut provides similar exception handling mechanism. </p> <p>For example, create an <code>PostNotFoundException</code> to stand for the case if the post was not found by a specified id.</p> <p>Create a <code>PostNotFoundException</code> class. </p> <pre><code>public class PostNotFoundException extends RuntimeException \n    public PostNotFoundException(UUID id) {\n        super(\"Post[id=\" + id + \"] was not found\");\n    }\n}\n</code></pre> <p>In the <code>PostController</code>,  throw this exception in the <code>Optional.orElseThrow</code> block.</p> <pre><code>@Get(uri = \"/{id}\", produces = MediaType.APPLICATION_JSON)\npublic HttpResponse&lt;?&gt; getById(@PathVariable UUID id) {\n    return posts.findById(id)\n        .map(p -&gt; ok(new PostDetailsDto(p.getId(), p.getTitle(), p.getContent(), p.getStatus(), p.getCreatedAt())))\n        .orElseThrow(() -&gt; new PostNotFoundException(id));\n}\n</code></pre> <p>Add a <code>PostNotFoundExceptionHandler</code> to handle <code>PostNotFoundException</code>.</p> <pre><code>@Produces\n@Singleton\n@Requires(classes = { PostNotFoundException.class})\n@RequiredArgsConstructor\npublic class PostNotFoundExceptionHandler implements ExceptionHandler&lt;PostNotFoundException, HttpResponse&lt;?&gt;&gt; {\n    private final ErrorResponseProcessor&lt;?&gt; errorResponseProcessor;\n\n    @Override\n    public HttpResponse&lt;?&gt; handle(HttpRequest request, PostNotFoundException exception) {\n        return errorResponseProcessor.processResponse(\n                ErrorContext.builder(request)\n                        .cause(exception)\n                        .errorMessage(exception.getMessage())\n                        .build(),\n                HttpResponse.notFound()\n        );\n    }\n}\n</code></pre> <p>Open a terminal,  use <code>curl</code> command to test the <code>/posts/{id}</code> endpoint with a non-existing id.</p> <pre><code># curl http://localhost:8080/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf -v\n&gt; GET /posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf HTTP/1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl/7.55.1\n&gt; Accept: */*\n&gt;\n&lt; HTTP/1.1 404 Not Found\n&lt; Content-Type: application/json\n&lt; date: Mon, 25 Oct 2021 07:02:01 GMT\n&lt; content-length: 301\n&lt; connection: keep-alive\n&lt;\n{\n  \"message\" : \"Not Found\",\n  \"_links\" : {\n    \"self\" : {\n      \"href\" : \"/posts/b6fb90ab-2719-498e-a5fd-93d0c7669fdf\",\n      \"templated\" : false\n    }\n  },\n  \"_embedded\" : {\n    \"errors\" : [ {\n      \"message\" : \"Post[id=b6fb90ab-2719-498e-a5fd-93d0c7669fdf] was not found\"\n    } ]\n  }\n}\n</code></pre>"},{"location":"gs/gs-rest/#handling-pagination","title":"Handling Pagination","text":"<p>Change the <code>getAll</code> method of <code>PostController</code> to the following.</p> <pre><code>@Get(uri = \"/\", produces = MediaType.APPLICATION_JSON)\n@Transactional\npublic HttpResponse&lt;Page&lt;PostSummaryDto&gt;&gt; getAll(@QueryValue(defaultValue = \"\") String q,\n                                                 @QueryValue(defaultValue = \"\") String status,\n                                                 @QueryValue(defaultValue = \"0\") int page,\n                                                 @QueryValue(defaultValue = \"10\") int size) {\n    var pageable = Pageable.from(page, size, Sort.of(Sort.Order.desc(\"createdAt\")));\n    var postStatus = StringUtils.hasText(status) ? com.example.domain.Status.valueOf(status) : null;\n    var data = this.posts.findAll(PostSpecifications.filterByKeywordAndStatus(q, postStatus), pageable);\n    var body = data.map(p -&gt; new PostSummaryDto(p.getId(), p.getTitle(), p.getCreatedAt()));\n    return ok(body);\n}\n</code></pre> <p>All the query parameters are optional. </p> <p>Let's use <code>curl</code> to test the /posts endpoint again.</p> <pre><code># curl http://localhost:8080/posts\n{\n  \"content\" : [ {\n    \"id\" : \"c9ec963d-2df5-4d65-bfbe-5a0d4cb14ca6\",\n    \"title\" : \"Getting started wit Micronaut\",\n    \"createdAt\" : \"2021-10-25T16:35:03.732951\"\n  }, {\n    \"id\" : \"0a79185c-5981-4301-86d1-c266b26b4980\",\n    \"title\" : \"Getting started wit Micronaut: part 2\",\n    \"createdAt\" : \"2021-10-25T16:35:03.732951\"\n  } ],\n  \"pageable\" : {\n    \"number\" : 0,\n    \"sort\" : {\n      \"orderBy\" : [ {\n        \"property\" : \"createdAt\",\n        \"direction\" : \"DESC\",\n        \"ignoreCase\" : false,\n        \"ascending\" : false\n      } ],\n      \"sorted\" : true\n    },\n    \"size\" : 10,\n    \"offset\" : 0,\n    \"sorted\" : true,\n    \"unpaged\" : false\n  },\n  \"totalSize\" : 2,\n  \"totalPages\" : 1,\n  \"empty\" : false,\n  \"size\" : 10,\n  \"offset\" : 0,\n  \"numberOfElements\" : 2,\n  \"pageNumber\" : 0\n}\n</code></pre> <p>The <code>Page</code>  JSON results look a little tedious,  let's customize a Jackson <code>JsonSerializer</code> to clean up the JSON data string.</p>"},{"location":"gs/gs-rest/#customizing-jsonserializer","title":"Customizing JsonSerializer","text":"<p>Create a <code>PageJsonSerializer</code> to process the <code>Page</code> object as you expected.</p> <pre><code>@Singleton\npublic class PageJsonSerializer extends JsonSerializer&lt;Page&lt;?&gt;&gt; {\n    @Override\n    public void serialize(Page&lt;?&gt; value, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n        gen.writeStartObject();\n        gen.writeNumberField(\"pageNumber\", value.getPageNumber());\n        if (value.getNumberOfElements() != value.getSize()) {\n            //only display it in the last page when number of elements is not equal to page size.\n            gen.writeNumberField(\"numberOfElements\", value.getNumberOfElements());\n        }\n        gen.writeNumberField(\"size\", value.getSize());\n        gen.writeNumberField(\"totalPages\", value.getTotalPages());\n        gen.writeNumberField(\"totalSize\", value.getTotalSize());\n        gen.writeObjectField(\"content\", value.getContent());\n        gen.writeEndObject();\n    }\n}\n\n</code></pre> <p>Run the application, and hint /posts endpoint again.</p> <pre><code># curl http://localhost:8080/posts\n{\n  \"pageNumber\" : 0,\n  \"numberOfElements\" : 2,\n  \"size\" : 10,\n  \"totalPages\" : 1,\n  \"totalSize\" : 2,\n  \"content\" : [ {\n    \"id\" : \"53fb77d5-4159-4a80-bab9-c76d9a535b36\",\n    \"title\" : \"Getting started wit Micronaut\",\n    \"createdAt\" : \"2021-10-25T16:47:05.545594\"\n  }, {\n    \"id\" : \"aa02fd49-0c24-4f12-b204-2e48213c7a1e\",\n    \"title\" : \"Getting started wit Micronaut: part 2\",\n    \"createdAt\" : \"2021-10-25T16:47:05.545594\"\n  } ]\n}\n</code></pre>"},{"location":"gs/gs-rest/#creating-post","title":"Creating Post","text":"<p>We have discussed how to query posts by keyword and get a single post by id, in this section, we are moving on to creating a new post.</p> <p>According to the REST convention, we use a POST HTTP method to send a request on endpoint /posts, it accepts JSON data as the request body. </p> <pre><code>@io.micronaut.http.annotation.Post(uri = \"/\", consumes = MediaType.APPLICATION_JSON)\n@Transactional\npublic HttpResponse&lt;Void&gt; create(@Body CreatePostCommand dto) {\n    var data = Post.builder().title(dto.title()).content(dto.content()).build();\n    var saved = this.posts.save(data);\n    return HttpResponse.created(URI.create(\"/posts/\" + saved.getId()));\n}\n</code></pre> <p>The <code>CreatePostCommand</code> is a Record class.</p> <pre><code>@Introspected\npublic record CreatePostCommand(@NotBlank String title, @NotBlank String content) {\n}\n</code></pre> <p>The immutable characteristic of a Record is a good match with the DTO pattern. The <code>Introspected</code> annotation marks Micronaut plugin process the Bean validation at build time.</p> <p>The request body is deserialized as a POJO by built-in Jackson <code>JsonDesearilizer</code>s, it is annotated with a <code>@Body</code> annotation to indicate which target class (<code>CreatePostCommand</code>) it should be deserialized to. After the post data is saved, set the response header <code>Location</code> value to the URI of the newly created post.</p> <p>Run the application, try to add a post via <code>curl</code>, and then access the newly created post.</p> <pre><code># curl -X POST -v  -H \"Content-Type:application/json\" http://localhost:8080/posts -d \"{\\\"title\\\":\\\"test title\\\",\\\"content\\\":\\\"test content\\\"}\"\n&gt; POST /posts HTTP/1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl/7.55.1\n&gt; Accept: */*\n&gt; Content-Type:application/json\n&gt; Content-Length: 47\n&gt;\n* upload completely sent off: 47 out of 47 bytes\n&lt; HTTP/1.1 201 Created\n&lt; location: /posts/7db15639-62e3-4d3e-9cf4-f54413502ea6\n&lt; date: Mon, 25 Oct 2021 09:07:40 GMT\n&lt; connection: keep-alive\n&lt; transfer-encoding: chunked\n&lt;\n# curl http://localhost:8080/posts/7db15639-62e3-4d3e-9cf4-f54413502ea6\n{\n  \"id\" : \"7db15639-62e3-4d3e-9cf4-f54413502ea6\",\n  \"title\" : \"test title\",\n  \"content\" : \"test content\",\n  \"status\" : \"DRAFT\",\n  \"createdAt\" : \"2021-10-25T17:07:40.87621\"\n}\n</code></pre>"},{"location":"gs/gs-rest/#validating-request-body","title":"Validating Request Body","text":"<p>Generally, in a real-world application, we have to ensure the request data satisfies requirements. Micronaut has built-in Bean Validation support.</p> <p>In the above <code>CreatPostCommand</code> class, add Bean Validation annotations on the fields.</p> <pre><code>@Introspected\npublic record CreatePostCommand(@NotBlank String title, @NotBlank String content) {\n}\n</code></pre> <p>You have to add <code>@Introspected</code> annotation to let Micronaut plugin to preprocess bean validation annotations at build time, thus Bean Validation works without any Java Reflection APIs at runtime time.</p> <p>Add a <code>@Validated</code> on the <code>PostController</code> class to enable validation in the whole class.  </p> <p>The add a <code>@Valid</code> on the method argument which presents the request body.</p> <pre><code>@Validated\npublic class PostController {\n    public HttpResponse&lt;Void&gt; create(@Body @Valid CreatePostCommand dto) {...}\n    //...\n}\n</code></pre> <p>Open a terminal, try to create a Post with an empty  content field.</p> <pre><code>curl -X POST -v  -H \"Content-Type:application/json\" http://localhost:8080/posts -d \"{\\\"title\\\":\\\"test title\\\",\\\"content\\\":\\\"\\\"}\"\n&gt; POST /posts HTTP/1.1\n&gt; Host: localhost:8080\n&gt; User-Agent: curl/7.55.1\n&gt; Accept: */*\n&gt; Content-Type:application/json\n&gt; Content-Length: 35\n&gt;\n* upload completely sent off: 35 out of 35 bytes\n&lt; HTTP/1.1 400 Bad Request\n&lt; Content-Type: application/json\n&lt; date: Mon, 25 Oct 2021 09:23:22 GMT\n&lt; content-length: 237\n&lt; connection: keep-alive\n&lt;\n{\n  \"message\" : \"Bad Request\",\n  \"_embedded\" : {\n    \"errors\" : [ {\n      \"message\" : \"dto.content: must not be blank\"\n    } ]\n  },\n  \"_links\" : {\n    \"self\" : {\n      \"href\" : \"/posts\",\n      \"templated\" : false\n    }\n  }\n}\n</code></pre>"},{"location":"gs/gs-rest/#updating-existing-post","title":"Updating Existing Post","text":"<p>Follow the REST convention, to update an existing post, send a <code>PUT</code> to the /posts/{id} endpoint.  If it is successful, it returns a 204 status. If the post does not exist, return a 404 status code instead.</p> <p>The request body is the change data(encoded to JSON or XML,etc.) and should be validated by Bean Validator, if the validation fails, it returns 400 status and sends the validation errors to the response body. The validation exception is handled by the Micronaut exception handler automatically.</p> <pre><code>@Put(uri = \"/{id}\", consumes = MediaType.APPLICATION_JSON)\n@Transactional\npublic HttpResponse&lt;?&gt; update(@PathVariable UUID id, @Body @Valid UpdatePostCommand dto) {\n    return posts.findById(id)\n        .map(p -&gt; {\n            p.setTitle(dto.title());\n            p.setContent(dto.content());\n            this.posts.save(p);\n            return HttpResponse.noContent();\n        })\n        .orElseThrow(() -&gt; new PostNotFoundException(id));\n    //.orElseGet(HttpResponse::notFound);\n}\n</code></pre> <p>Similar to <code>CreatePostCommand</code>, <code>UpdatePostCommand</code> is  a record used to transfer data from reuqest.</p> <pre><code>@Introspected\npublic record UpdatePostCommand(@NotBlank String title, @NotBlank String content) {\n}\n</code></pre>"},{"location":"gs/gs-rest/#deleting-post","title":"Deleting Post","text":"<p>According to REST convention, to delete a single post, send a <code>DELETE</code> request on <code>/posts/{id}</code>, if it is successful, returns a 204 status. If the <code>id</code> does not exist, it returns a <code>404</code> instead.</p> <p>Add the following codes to the <code>PostController</code>.</p> <pre><code>@Delete(uri = \"/{id}\", produces = MediaType.APPLICATION_JSON)\n@Transactional\npublic HttpResponse&lt;?&gt; deleteById(@PathVariable UUID id) {\n    return posts.findById(id)\n        .map(p -&gt; {\n            this.posts.delete(p);\n            return HttpResponse.noContent();\n        })\n        .orElseThrow(() -&gt; new PostNotFoundException(id));\n    //.orElseGet(HttpResponse::notFound);\n}\n</code></pre>"},{"location":"gs/gs-rest/#processing-subresources","title":"Processing Subresources","text":"<p>In our application, the <code>Comment</code> resource should be a subresource of <code>Post</code> resource. When adding comments or fetching comments of a specific <code>Post</code>, design the following comments APIs.</p> <ul> <li><code>POST /posts/{id}/comments</code> , add  a <code>Comment</code> resource to a specific <code>Post</code>.</li> <li><code>GET /posts/{id}/comments</code>, get all comments of a certain <code>Post</code> which id value is the path variable <code>id</code>.</li> </ul> <pre><code>// nested comments endpoints\n@Get(uri = \"/{id}/comments\", produces = MediaType.APPLICATION_JSON)\npublic HttpResponse&lt;?&gt; getCommentsByPostId(@PathVariable UUID id) {\n    return posts.findById(id)\n        .map(post -&gt; {\n            var comments = this.comments.findByPost(post);\n            return ok(comments.stream().map(c -&gt; new CommentDetailsDto(c.getId(), c.getContent(), c.getCreatedAt())));\n        })\n        .orElseThrow(() -&gt; new PostNotFoundException(id));\n    //.orElseGet(HttpResponse::notFound);\n}\n\n@io.micronaut.http.annotation.Post(uri = \"/{id}/comments\", consumes = MediaType.APPLICATION_JSON)\n@Transactional\npublic HttpResponse&lt;?&gt; createComment(@PathVariable UUID id, @Body @Valid CreateCommentCommand dto) {\n\n    return posts.findById(id)\n        .map(post -&gt; {\n            var data = Comment.builder().content(dto.content()).post(post).build();\n            post.getComments().add(data);\n            var saved = this.comments.save(data);\n            return HttpResponse.created(URI.create(\"/comments/\" + saved.getId()));\n        })\n        .orElseThrow(() -&gt; new PostNotFoundException(id));\n    // .orElseGet(HttpResponse::notFound);\n\n}\n</code></pre>"},{"location":"gs/gs-rest/#example-codes","title":"Example Codes","text":"<p>The example codes are hosted on my GitHub, check hantsy/micronaut-sandbox#post-service.</p>"},{"location":"gs/jakarta-data/","title":"Data Access with Micronaut Jakarta Data","text":"<p>Micronaut is a modern, JVM-based framework designed for building cloud-native microservices and serverless applications. Previously, we explored how to create RESTful backend applications with various Micronaut Data modules, including Data JPA, Data JDBC, Data R2dbc, and Data MongoDB.</p> <p>With the release of Micronaut 4.9, support for the Jakarta Data specification (introduced in Jakarta EE 11) is now available, providing a standardized alternative to traditional data persistence approaches. In previous articles, we explored how to integrate Jakarta Data with Spring and Quarkus. In this guide, we'll focus on using Jakarta Data within a Micronaut application to handle data access.</p>"},{"location":"gs/jakarta-data/#generating-the-project-skeleton","title":"Generating the Project Skeleton","text":"<p>Navigate to the Micronaut Launch page and select the following options to generate your project skeleton:</p> <ul> <li>Micronaut Version: 4.9.1 (latest stable version at the time of writing)</li> <li>Java Version: 21</li> <li>Language: Java</li> <li>Build Tools: Gradle Kotlin</li> <li>Test Framework: JUnit</li> </ul> <p>Keep the other options at their defaults.</p> <p>Next, click the FEATURES button and add these essential dependencies: Jakarta Data, Lombok, Reactor, Data JPA, HttpClient, Postgres, and TestContainers in the dialog.</p> <p>Then click the GENERATE button to download the generated archive, extract the files to your local system, and import the project into your favorite IDE, such as IntelliJ IDEA.</p> <p>[!NOTE] There is a typo in the generated build.gradle.kts in the current version. For more details, see: https://github.com/micronaut-projects/micronaut-starter/issues/2827. Simply change <code>implementation(\"jakarta.data:jakarta-data-api\")</code> to <code>implementation(\"jakarta.data:jakarta.data-api:1.0.1\")</code> to resolve this issue temporarily.</p> <p>Additionally, add Lombok to the <code>testCompileOnly</code> and <code>testAnnotationProcessor</code> scopes, and organize the dependencies for clarity. You can check the final modified build script here.</p>"},{"location":"gs/jakarta-data/#integrating-jakarta-data","title":"Integrating Jakarta Data","text":"<p>The Jakarta Data specification does not prescribe how entities should be defined. In Micronaut, the entity definitions still rely on the existing conventions and approaches provided by Micronaut Data.</p> <p>Let's start by creating a simple Jakarta Persistence <code>@Entity</code> class and an <code>@Embeddable</code> class:</p> <pre><code>// Customer.java\n@Introspected\n@Entity\n@Table(name = \"CUSTOMERS\")\n@Serdeable\n@AllArgsConstructor\n@NoArgsConstructor\n@Data\npublic class Customer {\n    @Id\n    @GeneratedValue(generator = \"uuid\")\n    @GenericGenerator(name = \"uuid\", strategy = \"uuid2\")\n    UUID id;\n    String name;\n    Integer age;\n    @Embedded Address address;\n    @Version Long version;\n\n    public static Customer of(String name, Integer age, Address address) {\n        return new Customer(null, name, age, address, null);\n    }\n}\n\n// Address.java\n@Introspected\n@Embeddable\n@Serdeable\npublic record Address(\n        String street,\n        String city,\n        String zip) {\n\n    public static Address of(String street, String city, String zip) {\n        return new Address(street, city, zip);\n    }\n}\n</code></pre> <p>In the above code fragments:</p> <ul> <li>Lombok annotations automatically generate setters, getters, <code>equals</code>, <code>hashCode</code>, and a no-argument constructor, all of which are required for Jakarta Persistence <code>Entity</code> classes.</li> <li><code>@Introspected</code> is necessary for Ahead-of-Time (AOT) compilation, especially if you plan to build a native image of your application.</li> <li><code>@Serdeable</code> (from the Micronaut Serde module) provides portable serialization and deserialization support compatible with formats like Jackson and BSON.</li> <li>The <code>@Entity</code> and <code>@Table</code> annotations on the <code>Customer</code> class designate it as a Jakarta Persistence entity and specify the corresponding database table. The <code>@Embeddable</code> annotation on the <code>Address</code> class marks it as a component that can be embedded within other entities, such as the <code>address</code> field in <code>Customer</code>, which is annotated with <code>@Embedded</code>. The <code>@Id</code> annotation identifies the primary key field, while <code>@GeneratedValue</code> and <code>@GenericGenerator</code> configure the ID generation strategy. The <code>@Version</code> field enables optimistic locking for transactional consistency.</li> </ul> <p>Jakarta Data introduces a completely new <code>Repository</code> abstraction to simplify data access. At its core is the top-level <code>DataRepository</code> interface, which is extended by <code>BasicRepository</code> and <code>CrudRepository</code> for general CRUD operations.</p> <p>You can define a <code>CustomerRepository</code> interface as shown below:</p> <pre><code>@Repository\npublic interface CustomerRepository extends CrudRepository&lt;Customer, UUID&gt; {\n}\n</code></pre> <p>[!NOTE] Ensure that both <code>@Repository</code> and <code>CrudRepository</code> are imported from the <code>jakarta.data</code> package.</p> <p>To build the project, run this command in a terminal window:</p> <pre><code>./gradlew build\n</code></pre> <p>Once the build completes, navigate to the build/classes directory. In addition to the <code>CustomerRepository</code> class, you will find a generated <code>CustomerRepository$Intercepted</code> file. You can open this file in your IDE (such as IntelliJ IDEA), where it will be decompiled into readable Java source code.</p> <pre><code>@Generated\nclass CustomerRepository$Intercepted implements CustomerRepository, Introduced {\n    private final Interceptor[][] $interceptors;\n    private final ExecutableMethod[] $proxyMethods;\n\n    public List&lt;Object&gt; updateAll(List&lt;Object&gt; entities) {\n        return (List)(new MethodInterceptorChain(this.$interceptors[1], this, this.$proxyMethods[1], new Object[]{entities})).proceed();\n    }\n\n    public Object update(Object entity) {\n        return (new MethodInterceptorChain(this.$interceptors[2], this, this.$proxyMethods[2], new Object[]{entity})).proceed();\n    }\n\n    public List&lt;Object&gt; insertAll(List&lt;Object&gt; entities) {\n        return (List)(new MethodInterceptorChain(this.$interceptors[3], this, this.$proxyMethods[3], new Object[]{entities})).proceed();\n    }\n    // ...\n}\n</code></pre> <p>As you can see, all methods defined in <code>BasicRepository</code> and <code>CrudRepository</code> are translated into concrete implementations within the generated class.</p> <p>Additionally, two helper classes - <code>$CustomerRepository$Intercepted$Definition</code> and <code>$CustomerRepository$Intercepted$Definition$Exec</code> are generated to facilitate the registration of <code>CustomerRepository</code> into the Micronaut Bean context.</p> <p>The Jakarta Data <code>Repository</code> abstraction also supports derived queries by method names, pagination, and custom queries using the <code>@Query</code> annotation. For example:</p> <pre><code>@Repository\npublic interface CustomerRepository extends CrudRepository&lt;Customer, UUID&gt; {\n    Optional&lt;Customer&gt; findByName(String name);\n\n    Page&lt;Customer&gt; findByAddressCityLike(String cityLike, PageRequest pageRequest);\n\n    List&lt;Customer&gt; findByAddressZip(String zip, Order&lt;Customer&gt; order);\n\n    @Query(\"where name like :name\")\n    @OrderBy(\"name\")\n    Customer[] byNameLike(@Param(\"name\") String customerName);\n}\n</code></pre> <p>These methods mirror the familiar patterns from Micronaut Data and Spring Data <code>Repository</code> abstractions, so you can use them naturally and intuitively in your code.</p> <p>For example, invoking a repository method looks just like a regular Java call:</p> <pre><code>customerRepository.findByAddressCityLike(\"New%\", PageRequest.of(1, 10, true));\n</code></pre> <p>[!WARNING] Jakarta Data uses 1-based pagination, so page numbers start at 1 instead of 0. As a developer, I had been familiar with 0-based pagination in projects for several years. It is better to let developers make the decision. For details, check the related discussion: jakarta/data#941.</p> <p>Another compelling aspect of Jakarta Data is its support for lifecycle-based methods that automatically infer the entity type from method parameters or return types. This allows you to define flexible, free-form interfaces for performing simple CRUD operations on your entities, without being tied to a specific repository abstraction.</p> <pre><code>@Repository\npublic interface CustomerDao {\n    @Find\n    @OrderBy(\"name\")\n    List&lt;Customer&gt; findAll();\n\n    @Find\n    Optional&lt;Customer&gt; findById(@By(ID) UUID id);\n\n    // @Find\n    // List&lt;Customer&gt; findByCity(@By(\"address.city\") String city, Limit limit, Sort&lt;?&gt;... sort);\n\n    @Insert\n    Customer save(Customer data);\n\n    @Update\n    void update(Customer data);\n\n    @Delete\n    void delete(Customer data);\n}\n</code></pre> <p>Please note that some methods that worked well in the Hibernate Jakarta Data implementation are currently problematic in the Micronaut Jakarta Data implementation. For more details, refer to micronaut-data#3487. Additionally, invoking the underlying data store handler within custom <code>default</code> methods is not yet possible, as discussed in micronaut-data#3490.</p> <p>You can explore the complete example project on GitHub, which also demonstrates testing against a real database using Testcontainers.</p>"},{"location":"gs/jakarta-data/#jdbc-support","title":"JDBC Support","text":"<p>Unlike the Jakarta Data implementation Hiberante, which is heavily dependent on Hibernate's <code>StatelessSession</code>. Micronaut Data extends Jakarta Data support to all its data modules, including JDBC and MongoDB.</p> <p>To use Jakarta Data with JDBC, simply select <code>Data JDBC</code> instead of <code>Data JPA</code> when generating your project skeleton.</p> <p>In your <code>CustomerRepository</code> interface, annotate it with both <code>@Repository</code> from Jakarta Data and <code>@JdbcRepository</code> from Micronaut Data:</p> <pre><code>@Repository\n@JdbcRepository\npublic interface CustomerRepository extends CrudRepository&lt;Customer, UUID&gt; {\n    // ...\n}\n</code></pre> <p>You can define the <code>Customer</code> entity using the standard Micronaut Data annotations:</p> <pre><code>// Customer.java\n@Introspected\n@MappedEntity(value = \"customers\")\n@Serdeable\npublic record Customer(\n        @Id @AutoPopulated UUID id,\n        String name,\n        Integer age,\n        @Relation(EMBEDDED) Address address,\n        @Version Long version\n) {\n    public static Customer of(String name, Integer age, Address address) {\n        return new Customer(null, name, age, address, null);\n    }\n}\n\n// Address.java\n@Introspected\n@Embeddable\n@Serdeable\npublic record Address(\n        @MappedProperty(\"street\") String street,\n        @MappedProperty(\"city\") String city,\n        @MappedProperty(\"zip\") String zip\n) {\n    public static Address of(String street, String city, String zip) {\n        return new Address(street, city, zip);\n    }\n}\n</code></pre> <p>Micronaut Data Jdbc allows you to define entities with the Jakarta Persistence API. If you prefer to use Jakarta Persistence annotations, add the <code>jakarta.persistence-api</code> dependency to your project.</p> <p>You can find the complete example project updated for JDBC.</p>"},{"location":"gs/jakarta-data/#mongodb-support","title":"MongoDB Support","text":"<p>Similarly, to use Jakarta Data with MongoDB, select <code>Data MongoDB</code> instead of <code>Data JPA</code> when generating your project, and remove <code>Postgres</code> from the feature list.</p> <p>Micronaut Data MongoDB also reuses the same data annotations to manage entities. However, by default, it does not support <code>UUID</code> as an ID type; use a <code>String</code> or MongoDB-specific <code>ObjectId</code> instead.</p> <pre><code>// Customer.java\n@Introspected\n@MappedEntity(value = \"customers\")\n@Serdeable\npublic record Customer(\n        @Id @AutoPopulated String id,\n        // ...\n) {\n    // ...\n}\n</code></pre> <p>Annotate your <code>CustomerRepository</code> interface with both <code>@Repository</code> and <code>@MongoRepository</code>:</p> <pre><code>@Repository\n@MongoRepository\npublic interface CustomerRepository extends CrudRepository&lt;Customer, String&gt; {\n    // ...\n}\n</code></pre> <p>You can explore the complete example project updated for MongoDB.</p>"},{"location":"gs/jakarta-data/#summary","title":"Summary","text":"<p>With Micronaut 4.9, support for the Jakarta Data specification introduces a standardized way to handle data access, providing an alternative approach for working with both relational databases and NoSQL stores.</p>"},{"location":"gs/jdbc-kotlin/","title":"Building RESTful API with Micronaut Data Jdbc and Kotlin","text":"<p>Micronaut Data also has great support for Jdbc and R2dbc. In this post, we will explore the Micronaut Data Jdbc and write the example in Kotlin language, and finally we will test the components with Kotest.</p>"},{"location":"gs/jdbc-kotlin/#getting-started","title":"Getting Started","text":"<p>Open your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page.</p> <ul> <li> <p>Java version:  17</p> </li> <li> <p>Language: Kotlin </p> </li> <li> <p>Build tool: Gradle</p> </li> <li> <p>Test framework: Kotest</p> </li> <li> <p>Included Features: data-jdbc, postgres, etc.</p> </li> </ul> <p>Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.</p> <p>Create an Entity class.</p> <pre><code>@MappedEntity(value = \"posts\", namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)\ndata class Post(\n    @field:Id @field:GeneratedValue(GeneratedValue.Type.UUID) var id: UUID? = null,\n    var title: String,\n    var content: String,\n    var status: Status? = Status.DRAFT,\n    @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()\n)\n</code></pre> <p>Here we declare a Kotlin <code>data class</code> to present the data in the mapped table. Similar to the JPA annotations, you can set <code>ID</code> and <code>GeneratedValue</code> on the field mapped to the primary key of the backend table. Similar to the Auditing feature of Spring Data project, the <code>createdAt</code> field annotated with <code>@DateCreated</code> will be filled automatically when the entity is being persisted.</p> <p>The status is an enum class.</p> <pre><code>enum class Status {\n    DRAFT, PENDING_MODERATED, PUBLISHED, REJECTED\n}\n</code></pre> <p>Note: The <code>ID</code> and <code>GeneratedValue</code> is from <code>io.micronaut.data.annotation</code> package.</p> <p>Create a <code>Repository</code>  for <code>Post</code> Entity class.</p> <pre><code>@JdbcRepository\ninterface PostRepository : PageableRepository&lt;Post, UUID&gt;\n</code></pre> <p>Here we used a <code>JdbcRepository</code> to indicate this Repository is  a data-jdbc <code>Repository</code>.</p> <p>Create a bean to initialize some sample data.</p> <pre><code>@Singleton\n@Requires(notEnv = [\"mock\"])\nclass DataInitializer(private val posts: PostRepository) {\n\n    @EventListener\n    fun onStartUp(e: ServerStartupEvent) {\n        log.info(\"starting data initialization at ServerStartupEvent: $e\")\n\n        posts.deleteAll()\n\n        val data = listOf(\n            Post(title = \"Building Restful APIs with Micronaut and Kotlin\", content = \"test\"),\n            Post(title = \"Building Restful APIs with Micronaut and Kotlin: part 2\", content = \"test\")\n        )\n        data.forEach { log.debug(\"saving: $it\") }\n        posts.saveAll(data).forEach { log.debug(\"saved post: $it\") }\n        log.info(\"data initialization is done...\")\n    }\n\n    companion object DataInitializer {\n        private val log = LoggerFactory.getLogger(DataInitializer::class.java)\n    }\n\n}\n\n</code></pre> <p>Now create a controller to expose RESTful APIs.</p> <pre><code>@Controller(\"/posts\")\nclass PostController(private val posts: PostRepository) {\n\n    @Get(uri = \"/\", produces = [MediaType.APPLICATION_JSON])\n    fun all(): HttpResponse&lt;List&lt;Post&gt;&gt; = ok(posts.findAll().toList())\n\n    @Get(uri = \"/{id}\", produces = [MediaType.APPLICATION_JSON])\n    fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; {\n        val post = posts.findById(id) ?: return notFound()\n        return ok(post)\n    }\n\n    @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON])\n    fun create(@Body body: Post): HttpResponse&lt;Any&gt; {\n        val saved = posts.save(body)\n        return created(URI.create(\"/posts/\" + saved.id))\n    }\n}\n</code></pre> <p>Now let's try to start up the application, make sure there is a running Postgres database, the database settings  should match the configuration in the application.yaml. </p> <p>Simply, you can prepare the database through docker compose file. Run the following command to start a Postgres in docker, the database details is defined in the docker-compose.yaml.</p> <pre><code># docker compose up postgres\n</code></pre> <p>Now run the application.</p> <pre><code># gradlew run \n// or \n# gradlew build\n# java build/xxx.jar\n</code></pre> <p>You can use <code>curl</code> command to test the /posts endpoint.</p> <pre><code># curl http://localhost:8080/posts\n</code></pre>"},{"location":"gs/jdbc-kotlin/#query-by-specification","title":"Query by Specification","text":"<p>If you have some experience of Spring Data JPA, you will be impressed by the JPA Specification, but it only works with Spring Data JPA. In Micronaut Data, the data-jdbc also supports query by JPA Specification. </p> <p>Add  <code>jakarta.persistence:jakarta.persistence-api:3.0.0</code> into dependencies.</p> <p>Change <code>PostRepository</code>, make it extends <code>JpaSpecificationExecutor</code>.</p> <pre><code>@JdbcRepository\ninterface PostRepository : PageableRepository&lt;Post, UUID&gt;, JpaSpecificationExecutor&lt;Post&gt;\n</code></pre> <p>Create a series of <code>Specfication</code>, eg.  find by title, find by keyword, or reject all posts that status is <code>PENDING_MODERATED</code>, remove all <code>REJECTED</code> posts.  In the Micronaut Data, there are some variants of the <code>PredicateSpecification</code>, such as <code>QuerySpecificaiton</code>, <code>UpdateSpecification</code>,  and <code>DeleteSpecification</code>.</p> <pre><code>object Specifications {\n\n    fun titleLike(title: String): PredicateSpecification&lt;Post&gt; {\n        return PredicateSpecification&lt;Post&gt; { root, criteriaBuilder -&gt;\n            criteriaBuilder.like(\n                root.get(\"title\"),\n                \"%$title%\"\n            )\n        }\n    }\n\n    fun byKeyword(q: String): QuerySpecification&lt;Post&gt; {\n        return QuerySpecification&lt;Post&gt; { root, query, criteriaBuilder -&gt;\n            criteriaBuilder.or(\n                criteriaBuilder.like(root.get(\"title\"), \"%$q%\"),\n                criteriaBuilder.like(root.get(\"content\"), \"%$q%\")\n            )\n        }\n    }\n\n    fun rejectAllPendingModerated(): UpdateSpecification&lt;Post&gt; {\n        return UpdateSpecification&lt;Post&gt; {root, query, criteriaBuilder -&gt;\n            query.set(root.get(\"status\"), Status.REJECTED)\n            criteriaBuilder.equal(root.get&lt;Status&gt;(\"status\"), Status.PENDING_MODERATED)\n        }\n    }\n\n    fun removeAllRejected(): DeleteSpecification&lt;Post&gt; {\n        return DeleteSpecification&lt;Post&gt; {root, query, criteriaBuilder -&gt;\n            criteriaBuilder.equal(root.get&lt;Status&gt;(\"status\"), Status.REJECTED)\n        }\n    }\n\n}\n</code></pre> <p>Let's create some tests to verify these Specifications.</p> <pre><code>@MicronautTest(environments = [Environment.TEST], startApplication = false)\nopen class PostRepositoryAnnotationSpec() : AnnotationSpec() {\n    companion object {\n        private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java)\n    }\n\n    @Inject\n    private lateinit var posts: PostRepository\n\n    @Inject\n    private lateinit var template: JdbcOperations\n\n    @Inject\n    private lateinit var tx: TransactionOperations&lt;Any&gt;\n\n    @BeforeEach\n    fun beforeEach() {\n        val callback: TransactionCallback&lt;Any, Int&gt; = TransactionCallback { _: TransactionStatus&lt;Any&gt; -&gt;\n            val sql = \"delete from posts\";\n            this.template.prepareStatement(sql) {\n                it.executeUpdate()\n            }\n        }\n\n        val cnt = tx.executeWrite(callback)\n        println(\"deleted $cnt\");\n    }\n\n    @Test\n    fun `test save and find posts`() {\n        val sql = \"insert into posts(title, content, status) values (?, ?, ?)\";\n        val insertedCnt = template.prepareStatement(sql) {\n            it.setString(1, \"test title\")\n            it.setString(2, \"test content\")\n            it.setString(3, \"DRAFT\")\n            it.executeUpdate()\n        }\n\n        insertedCnt shouldBeEqualComparingTo 1\n        val all = posts.findAll()\n        all shouldHaveSize 1\n        log.debug(\"all posts: $all\")\n        all.map { it.title }.forAny { it shouldContain \"test\" }\n    }\n\n    @Test\n    fun `find by title`() {\n        val sql = \"insert into posts(title, content, status) values (?, ?, ?)\";\n        val insertedCnt = template.prepareStatement(sql) {\n            it.setString(1, \"test title\")\n            it.setString(2, \"test content\")\n            it.setString(3, \"DRAFT\")\n            it.executeUpdate()\n        }\n\n        insertedCnt shouldBeEqualComparingTo 1\n        val all = posts.findAll(Specifications.titleLike(\"test\"))\n        log.debug(\"all posts size:{}\", all.size)\n        all shouldHaveSize 1\n\n        val all2 = posts.findAll(Specifications.titleLike(\"test2\"))\n        log.debug(\"all2 posts size:{}\", all2.size)\n        all2 shouldHaveSize 0\n    }\n\n    @Test\n    fun `find by keyword`() {\n        val sql = \"insert into posts(title, content, status) values (?, ?, ?)\";\n        val insertedCnt = template.prepareStatement(sql) {\n            it.setString(1, \"test title\")\n            it.setString(2, \"test content\")\n            it.setString(3, \"DRAFT\")\n            it.addBatch()\n            it.setString(1, \"test2 title\")\n            it.setString(2, \"test2 content\")\n            it.setString(3, \"DRAFT\")\n            it.addBatch()\n            it.executeBatch()\n        }\n\n        insertedCnt.any { it == 1 }\n        val all = posts.findAll(Specifications.byKeyword(\"test\"))\n        log.debug(\"all posts size:{}\", all.size)\n        all shouldHaveSize 2\n\n        val all2 = posts.findAll(Specifications.byKeyword(\"test2\"))\n        log.debug(\"all2 posts size:{}\", all2.size)\n        all2 shouldHaveSize 1\n    }\n\n    @Test\n    fun `update posts`() {\n        val sql = \"insert into posts(title, content, status) values (?, ?, ?)\";\n        val insertedCnt = template.prepareStatement(sql) {\n            it.setString(1, \"test title\")\n            it.setString(2, \"test content\")\n            it.setString(3, \"PENDING_MODERATED\")\n            it.addBatch()\n            it.setString(1, \"test2 title\")\n            it.setString(2, \"test2 content\")\n            it.setString(3, \"PENDING_MODERATED\")\n            it.addBatch()\n            it.executeBatch()\n        }\n\n        insertedCnt.any { it == 1 }\n        val updated = posts.updateAll(Specifications.rejectAllPendingModerated())\n        log.debug(\"updated posts size:{}\", updated)\n        updated shouldBe 2\n\n        val all = posts.findAll()\n        all shouldHaveSize 2\n        all.map { it.status }.forAny { it shouldBe Status.REJECTED }\n    }\n\n    @Test\n    fun `remove posts`() {\n        val sql = \"insert into posts(title, content, status) values (?, ?, ?)\";\n        val insertedCnt = template.prepareStatement(sql) {\n            it.setString(1, \"test title\")\n            it.setString(2, \"test content\")\n            it.setString(3, \"REJECTED\")\n            it.addBatch()\n            it.setString(1, \"test2 title\")\n            it.setString(2, \"test2 content\")\n            it.setString(3, \"DRAFT\")\n            it.addBatch()\n            it.executeBatch()\n        }\n\n        insertedCnt.any { it == 1 }\n        val deleted = posts.deleteAll(Specifications.removeAllRejected())\n        log.debug(\"deleted posts size:{}\", deleted)\n        deleted shouldBe 1\n\n        val all = posts.findAll()\n        all shouldHaveSize 1\n        all.map { it.status }.forAny { it shouldBe Status.DRAFT }\n    }\n}\n</code></pre> <p>Similar to Spring Jdbc and Spring Data Jdbc,  there is a template based <code>JdbcOperations</code> bean available for programmatic database operations. In the above testing codes, we used <code>JdbcOperations</code> to prepare and clean up sample data for each tests.</p> <p>In this application, we use Kotest as testing framework. </p> <p>Kotest provides a lot of testing code styles, some are inspired by the existing <code>describe/it</code> clause from NodeJS ecosystem or ScalaTest. </p> <p>The <code>AnnotationSpec</code> is similar to the traditional JUnit coding style, for those from JUnit, it is zero learning curve to migrate to Kotest testing framework.</p>"},{"location":"gs/jdbc-kotlin/#kotest","title":"Kotest","text":"<p>The simplest is <code>SpringSpec</code>, use a string to describe functionality. Let's rewrite the above testing codes with <code>StringSepc</code>.</p> <pre><code>@MicronautTest(environments = [Environment.TEST], startApplication = false)\nclass PostRepositoryTest(\n    private val posts: PostRepository,\n    private val template: JdbcOperations,\n    private val tx: TransactionOperations&lt;Any&gt;\n) : StringSpec({\n\n    \"test save and find posts\" {\n        val sql = \"insert into posts(title, content, status) values (?, ?, ?)\";\n        val insertedCnt = template.prepareStatement(sql) {\n            it.setString(1, \"test title\")\n            it.setString(2, \"test content\")\n            it.setString(3, \"DRAFT\")\n            it.executeUpdate()\n        }\n\n        insertedCnt shouldBeEqualComparingTo 1\n        val all = posts.findAll()\n        all shouldHaveSize 1\n        log.debug(\"all posts: $all\")\n        all.map { it.title }.forAny { it shouldContain \"test\" }\n    }\n\n    \"find by title\" {\n        val sql = \"insert into posts(title, content, status) values (?, ?, ?)\";\n        val insertedCnt = template.prepareStatement(sql) {\n            it.setString(1, \"test title\")\n            it.setString(2, \"test content\")\n            it.setString(3, \"DRAFT\")\n            it.executeUpdate()\n        }\n\n        insertedCnt shouldBeEqualComparingTo 1\n        val all = posts.findAll(Specifications.titleLike(\"test\"))\n        log.debug(\"all posts size:{}\", all.size)\n        all shouldHaveSize 1\n\n        val all2 = posts.findAll(Specifications.titleLike(\"test2\"))\n        log.debug(\"all2 posts size:{}\", all2.size)\n        all2 shouldHaveSize 0\n    }\n\n    \"find by keyword\" {\n        val sql = \"insert into posts(title, content, status) values (?, ?, ?)\";\n        val insertedCnt = template.prepareStatement(sql) {\n            it.setString(1, \"test title\")\n            it.setString(2, \"test content\")\n            it.setString(3, \"DRAFT\")\n            it.addBatch()\n            it.setString(1, \"test2 title\")\n            it.setString(2, \"test2 content\")\n            it.setString(3, \"DRAFT\")\n            it.addBatch()\n            it.executeBatch()\n        }\n\n        insertedCnt.any { it == 1 }\n        val all = posts.findAll(Specifications.byKeyword(\"test\"))\n        log.debug(\"all posts size:{}\", all.size)\n        all shouldHaveSize 2\n\n        val all2 = posts.findAll(Specifications.byKeyword(\"test2\"))\n        log.debug(\"all2 posts size:{}\", all2.size)\n        all2 shouldHaveSize 1\n    }\n\n    \"update posts\" {\n        val sql = \"insert into posts(title, content, status) values (?, ?, ?)\";\n        val insertedCnt = template.prepareStatement(sql) {\n            it.setString(1, \"test title\")\n            it.setString(2, \"test content\")\n            it.setString(3, \"PENDING_MODERATED\")\n            it.addBatch()\n            it.setString(1, \"test2 title\")\n            it.setString(2, \"test2 content\")\n            it.setString(3, \"PENDING_MODERATED\")\n            it.addBatch()\n            it.executeBatch()\n        }\n\n        insertedCnt.any { it == 1 }\n        val updated = posts.updateAll(Specifications.rejectAllPendingModerated())\n        log.debug(\"updated posts size:{}\", updated)\n        updated shouldBe 2\n\n        val all = posts.findAll()\n        all shouldHaveSize 2\n        all.map { it.status }.forAny { it shouldBe Status.REJECTED }\n    }\n\n    \"remove posts\" {\n        val sql = \"insert into posts(title, content, status) values (?, ?, ?)\";\n        val insertedCnt = template.prepareStatement(sql) {\n            it.setString(1, \"test title\")\n            it.setString(2, \"test content\")\n            it.setString(3, \"REJECTED\")\n            it.addBatch()\n            it.setString(1, \"test2 title\")\n            it.setString(2, \"test2 content\")\n            it.setString(3, \"DRAFT\")\n            it.addBatch()\n            it.executeBatch()\n        }\n\n        insertedCnt.any { it == 1 }\n        val deleted = posts.deleteAll(Specifications.removeAllRejected())\n        log.debug(\"deleted posts size:{}\", deleted)\n        deleted shouldBe 1\n\n        val all = posts.findAll()\n        all shouldHaveSize 1\n        all.map { it.status }.forAny { it shouldBe Status.DRAFT }\n    }\n\n}) {\n    companion object {\n        private val log: Logger = LoggerFactory.getLogger(PostControllerTest::class.java)\n    }\n\n    override fun beforeEach(testCase: TestCase) {\n        val callback: TransactionCallback&lt;Any, Int&gt; = TransactionCallback { _: TransactionStatus&lt;Any&gt; -&gt;\n            val sql = \"delete from posts\";\n            this.template.prepareStatement(sql) {\n                it.executeUpdate()\n            }\n        }\n\n        val cnt = tx.executeWrite(callback)\n        println(\"deleted $cnt\");\n    }\n}\n</code></pre> <p>Create a test to test <code>PostController</code>, here we use <code>FunSpec</code> which wraps tests in a test method block.</p> <pre><code>@MicronautTest(environments = [\"mock\"])\nclass PostControllerTest(\n    private val postsBean: PostRepository,\n    @Client(\"/\") private var client: HttpClient\n) : FunSpec({\n\n    test(\"test get posts endpoint\") {\n        val posts = getMock(postsBean)\n        every { posts.findAll() }\n            .returns(\n                listOf(\n                    Post(\n                        id = UUID.randomUUID(),\n                        title = \"test title\",\n                        content = \"test content\",\n                        status = Status.DRAFT,\n                        createdAt = LocalDateTime.now()\n                    )\n                )\n            )\n        val response = client.toBlocking().exchange(\"/posts\", Array&lt;Post&gt;::class.java)\n\n        response.status shouldBe HttpStatus.OK\n        response.body()!![0].title shouldBe \"test title\"\n\n        verify(exactly = 1) { posts.findAll() }\n    }\n}) {\n    @MockBean(PostRepository::class)\n    fun posts() = mockk&lt;PostRepository&gt;()\n}\n\n</code></pre> <p>Here we use mockk to create a mocked <code>PostRepository</code> and the <code>MockBean</code> is located in the body of <code>SpringSpec</code>. </p> <p>The following is an integration example which use <code>SpringSpec</code> .</p> <pre><code>@MicronautTest\nclass IntegrationTests(\n    private val application: EmbeddedApplication&lt;*&gt;,\n    @Client(\"/\") private val client: HttpClient\n) : StringSpec({\n\n    \"test the server is running\" {\n        assert(application.isRunning)\n    }\n\n    \"test GET /posts endpoint\" {\n        val response = client.toBlocking().exchange(\"/posts\", Array&lt;Post&gt;::class.java)\n\n        response.status shouldBe HttpStatus.OK\n        response.body()!!.map { it.title }.forAny {\n            it shouldContain \"Micronaut\"\n        }\n    }\n})\n</code></pre> <p>Get the complete source codes from my Github.</p>"},{"location":"gs/mongo-reactive/","title":"Building RESTful API with Micronaut Mongo Reative","text":"<p>In this post, we will explore the Micronaut Mongo Reactive feature. Unlike the Data JPA and R2dbc, the Mongo Reactive feature is not part of the Micronaut Data project. Micronaut Mongo Reactive is a light-weight wrapper of the official Mongo Java Drivers, and provides autoconfiguration of <code>MongoClient</code> from application properties.</p>"},{"location":"gs/mongo-reactive/#getting-started","title":"Getting Started","text":"<p>Open your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page.</p> <ul> <li> <p>Java version:  17</p> </li> <li> <p>Language: Java </p> </li> <li> <p>Build tool: Gradle</p> </li> <li> <p>Test framework: Spock</p> </li> <li> <p>Included Features: mongo-reactive etc.</p> </li> </ul> <p>Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.</p> <p>In the previous examples, we used JUnit and Kotest as testing framework, in this example, we switched to use Spock and Groovy to write tests.</p> <p>Create a Mongo document entity class.</p> <pre><code>@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor(staticName = \"of\")\npublic class Customer {\n    private ObjectId id;\n    private String name;\n    private int age;\n    private Address address;\n\n    public static Customer of(String name, int age, Address address) {\n        return Customer.of(null, name, age, address);\n    }\n}\n</code></pre> <p>The <code>Address</code> is an embedded Document in a  <code>Customer</code> Document.</p> <pre><code>@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor(staticName = \"of\")\npublic class Address {\n    private String street;\n    private String city;\n    private String zip;\n}\n</code></pre> <p>Create  a <code>Repository</code> class to perform CRUD operations on <code>Customer</code>.</p> <pre><code>@Singleton\n@RequiredArgsConstructor\n@Slf4j\npublic class CustomerRepository {\n    private final MongoClient mongoClient;\n    private final DefaultMongoConfiguration mongoConfiguration;\n\n    public Flux&lt;Customer&gt; findAll() {\n        return Flux.from(customersCollection().find());\n    }\n\n    public Mono&lt;Customer&gt; findById(ObjectId id) {\n        return Mono.from(customersCollection().find(Filters.eq(id)));\n    }\n\n    public Mono&lt;ObjectId&gt; insertOne(Customer data) {\n        return Mono.from(customersCollection().insertOne(data, new InsertOneOptions().bypassDocumentValidation(false)))\n                .mapNotNull(result -&gt; result.getInsertedId().asObjectId().getValue());\n    }\n\n    public Mono&lt;Map&lt;Integer, BsonValue&gt;&gt; insertMany(List&lt;Customer&gt; data) {\n        return Mono.from(customersCollection().insertMany(data, new InsertManyOptions().bypassDocumentValidation(false).ordered(true)))\n                .map(InsertManyResult::getInsertedIds);\n    }\n\n    public Mono&lt;Long&gt; deleteById(ObjectId id) {\n        return Mono.from(customersCollection().deleteOne(Filters.eq(id), new DeleteOptions()))\n                .map(DeleteResult::getDeletedCount);\n    }\n\n    public void init() {\n        var people = List.of(\n                Customer.of(\"Charles Babbage\", 45, Address.of(\"5 Devonshire Street\", \"London\", \"W11\")),\n                Customer.of(\"Alan Turing\", 28, Address.of(\"Bletchley Hall\", \"Bletchley Park\", \"MK12\")),\n                Customer.of(\"Timothy Berners-Lee\", 61, Address.of(\"Colehill\", \"Wimborne\", null))\n        );\n        Mono.from(customersCollection().drop())\n                .then()\n                .thenMany(this.insertMany(people))\n                .subscribe(\n                        result -&gt; result.forEach((key, value) -&gt; log.debug(\"saved key: {}, value: {}\", key, value)),\n                        error -&gt; log.debug(\"initialization failed: {}\", error),\n                        () -&gt; log.debug(\"done\")\n                );\n    }\n\n    public Mono&lt;Long&gt; deleteAll() {\n        return Mono.from(customersCollection().deleteMany(Filters.empty(), new DeleteOptions()))\n                .map(DeleteResult::getDeletedCount);\n    }\n\n    private MongoCollection&lt;Customer&gt; customersCollection() {\n        return mongoClient\n                .getDatabase(\"userdb\")\n                .getCollection(\"customers\", Customer.class);\n    }\n\n}\n</code></pre> <p>When a  <code>mongo.uri</code> is set in the application.yml,  there is a  reactive <code>MongoClient</code>  bean is available.</p> <p>In the above codes:</p> <ul> <li>The <code>customersCollection()</code> method defines a Mongo collection mapped to the <code>Customer</code> class. As you see, there is a <code>ObjectId</code> id field is defined in the <code>Customer</code> class, when saving a Customer instance, it will generate a new  ObjectId for it and  saving it to the customers document <code>_id</code> in MongoDB automatically.</li> <li>The <code>MongoClient</code> provides methods for CRUD operations,  but it is based on the Reactive Streams APIs. Here we use Reactor API in this project, we use <code>Mono</code> and <code>Flux</code> to wrap the operation result into Reactor friendly APIs.</li> </ul> <p>Now let's create  a test to test the <code>CustomerRepository</code>.</p> <pre><code>@MicronautTest(startApplication = false)\n@Slf4j\nclass CustomerRepositorySpec extends Specification {\n\n    @Inject\n    EmbeddedApplication&lt;?&gt; application\n\n    @Inject\n    CustomerRepository customerRepository;\n\n    def setup() {\n        CountDownLatch latch = new CountDownLatch(1)\n        customerRepository.deleteAll()\n                .doOnTerminate(_ -&gt; latch.countDown())\n                .subscribe(it -&gt; log.debug \"deleted customers: {}\", it)\n        latch.await(1000, TimeUnit.MILLISECONDS)\n    }\n\n    void 'application is not running'() {\n        expect:\n        !application.running\n    }\n\n    void 'test findAll'() {\n        given:\n        this.customerRepository.insertMany(List.of(Customer.of(\"Jack\", 40, null)))\n                .block(Duration.ofMillis(5000L))\n\n        when:\n        def result = this.customerRepository.findAll()\n\n        then:\n        StepVerifier.create(result)\n                .expectNextMatches(it -&gt; it.name == \"Jack\")\n                .expectComplete()\n                .verify()\n    }\n}\n\n</code></pre> <p>To test the persistence layer, we do not needs a running application. So add <code>startApplication = false</code> to the <code>MicronautTest</code> annotation. </p> <p>Generally, a Spock test is called a  <code>Specfication</code>,  you can override the lifecycle methods in your tests,  such as <code>setup</code>, <code>setupSpec</code> , etc.  Every test follows the BDD rule keywords, such as  <code>given</code> , <code>when</code> and <code>then</code>, etc. </p> <p>In the above codes, we override the <code>setup</code> method and clear the data in the database. And then create a test to verify the insert and find operations, in the <code>then</code> block, we use the <code>StepVerify</code> to assert the result in Reactive Streams.</p> <p>If you want to start up a Testcontainers Docker to serve the required Mongo database,  try to define a  Mongo container instance with <code>Shared</code> and <code>AutoCleanup</code> annotation, and override <code>setupSpec</code> to ensure it is available for all tests in this specification.</p> <pre><code>@Shared\n@AutoCleanup\nGenericContainer mongo = new GenericContainer(\"mongo\")\n    .withExposedPorts(27017)\n\ndef setupSpec() {        \n    mongo.start()\n}\n</code></pre> <p>Like the previous examples,  we can listen a <code>ServerStartupEvent</code> to initialize the sample data.</p> <pre><code>@Singleton\n@Requires(notEnv = \"mock\")\n@Slf4j\n@RequiredArgsConstructor\npublic class DataInitializer {\n    private final CustomerRepository customerRepository;\n\n    @EventListener\n    public void onStart(ServerStartupEvent event) {\n        log.debug(\"starting data initialization...\");\n        this.customerRepository.init();\n    }\n}\n</code></pre> <p>Try to create a  controller to expose the RESTful APIs.</p> <pre><code>@Controller(\"/customers\")\n@RequiredArgsConstructor\n@Slf4j\npublic class CustomerController {\n    private final CustomerRepository customerRepository;\n\n    @Get(uri = \"/\", produces = {MediaType.APPLICATION_JSON})\n    public Flux&lt;?&gt; all() {\n        return this.customerRepository.findAll();\n    }\n\n    @Get(uri = \"/{id}\", produces = {MediaType.APPLICATION_JSON})\n    public Mono&lt;MutableHttpResponse&lt;Customer&gt;&gt; byId(@PathVariable ObjectId id) {\n        return this.customerRepository.findById(id)\n                .map(HttpResponse::ok)\n                .switchIfEmpty(Mono.just(notFound()));\n    }\n\n    @Post(uri = \"/\", consumes = {MediaType.APPLICATION_JSON})\n    public Mono&lt;HttpResponse&lt;?&gt;&gt; create(@Body Customer data) {\n        return this.customerRepository.insertOne(data)\n                .map(id -&gt; created(URI.create(\"/customers/\" + id.toHexString())));\n    }\n\n    @Delete(uri = \"/{id}\")\n    public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) {\n        return this.customerRepository.deleteById(id)\n                .map(deleted -&gt; {\n                    if (deleted &gt; 0) {\n                        return noContent();\n                    } else {\n                        return notFound();\n                    }\n                });\n    }\n}\n\n</code></pre> <p>To process the <code>ObjectId</code> in the request path, create a <code>TypeConverter</code> to convert  id from String to <code>ObjectId</code>.</p> <pre><code>@Singleton\npublic class StringToObjectIdConverter implements TypeConverter&lt;String, ObjectId&gt; {\n\n    @Override\n    public Optional&lt;ObjectId&gt; convert(String object, Class&lt;ObjectId&gt; targetType, ConversionContext context) {\n        return Optional.of(new ObjectId(object));\n    }\n}\n</code></pre> <p>In order to serialize the id (<code>ObjectId</code> type) of <code>Customer</code> as a String in the HTTP response, create a <code>JsonSerializer</code> to customize the serialization process.  When it is applied,  the id field is serialized as a hex string instead of a JSON object.</p> <pre><code>@Singleton\npublic class ObjectIdJsonSerializer extends JsonSerializer&lt;ObjectId&gt; {\n\n    @Override\n    public void serialize(ObjectId value, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n        gen.writeString(value.toHexString());\n    }\n}\n</code></pre> <p>Create a test for the <code>CustomerController</code>.</p> <pre><code>@MicronautTest(environments = [\"mock\"])\nclass CustomerControllerSpec extends Specification {\n\n    @Inject\n    EmbeddedApplication&lt;?&gt; application\n\n    @Inject\n    @Client(\"/\")\n    ReactorHttpClient client\n\n    @Inject\n    CustomerRepository customerRepository\n\n    def 'test it works'() {\n        expect:\n        application.running\n    }\n\n    void 'get all customers'() {\n        given:\n        1 * customerRepository.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), \"Jack\", 40, null), Customer.of(ObjectId.get(), \"Rose\", 20, null))\n\n        when:\n        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(\"/customers\"), String).log()\n\n        then:\n        //1 * customers.findAll() &gt;&gt; Flux.just(Customer.of(ObjectId.get(), \"Jack\", 40, null), Customer.of(ObjectId.get(), \"Rose\", 20, null))\n        StepVerifier.create(resFlux)\n        //.expectNextCount(1)\n                .consumeNextWith(s -&gt; {\n                    assert s.getStatus() == HttpStatus.OK\n                    assert s.body().contains('Jack')\n                })\n                .expectComplete()\n                .verify()\n    }\n\n    void 'create a new customer'() {\n        given:\n        def objId = ObjectId.get()\n        1 * customerRepository.insertOne(_) &gt;&gt; Mono.just(objId)\n\n        when:\n        def body = Customer.of(null, \"Jack\", 40, null)\n        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.POST(\"/customers\", body), String).log()\n\n        then:\n        StepVerifier.create(resFlux)\n                .consumeNextWith(s -&gt; {\n                    assert s.getStatus() == HttpStatus.CREATED\n                    assert s.header(\"Location\") == '/customers/' + objId.toHexString()\n                })\n                .expectComplete()\n                .verify()\n    }\n\n    void 'get customer by id '() {\n        given:\n        1 * customerRepository.findById(_) &gt;&gt; Mono.just(Customer.of(ObjectId.get(), \"Jack\", 40, null))\n\n        when:\n        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(\"/customers/\" + ObjectId.get().toHexString()), String).log()\n\n        then:\n        StepVerifier.create(resFlux)\n                .consumeNextWith(s -&gt; {\n                    assert s.getStatus() == HttpStatus.OK\n                    assert s.body().contains('Jack')\n                })\n                .expectComplete()\n                .verify()\n    }\n\n    void 'get customer by none-existing id '() {\n        given:\n        1 * customerRepository.findById(_) &gt;&gt; Mono.empty()\n\n        when:\n        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.GET(\"/customers/\" + ObjectId.get().toHexString()), String).log()\n\n        then:\n        StepVerifier.create(resFlux)\n                .consumeErrorWith(error -&gt; {\n                    assert error instanceof HttpClientResponseException\n                    assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND\n                })\n                .verify()\n    }\n\n    void 'delete customer by id '() {\n        given:\n        1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(1L)\n\n        when:\n        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE(\"/customers/\" + ObjectId.get().toHexString()), String).log()\n\n        then:\n        StepVerifier.create(resFlux)\n                .consumeNextWith(s -&gt; {\n                    assert s.getStatus() == HttpStatus.NO_CONTENT\n                })\n                .expectComplete()\n                .verify()\n    }\n\n    void 'delete customer by none-existing id '() {\n        given:\n        1 * customerRepository.deleteById(_) &gt;&gt; Mono.just(0L)\n\n        when:\n        Flux&lt;HttpResponse&lt;String&gt;&gt; resFlux = client.exchange(HttpRequest.DELETE(\"/customers/\" + ObjectId.get().toHexString()), String).log()\n\n        then:\n        StepVerifier.create(resFlux)\n                .consumeErrorWith(error -&gt; {\n                    assert error instanceof HttpClientResponseException\n                    assert (error as HttpClientResponseException).status == HttpStatus.NOT_FOUND\n                })\n                .verify()\n    }\n\n    @MockBean(CustomerRepository)\n    CustomerRepository mockedCustomerRepository() {// must use explicit type declaration\n        Mock(CustomerRepository)\n    }\n}\n</code></pre> <p>In this test, we create a mock bean for <code>CustomerRepository</code>, note you have to declare type explicitly. In the <code>given</code> block, it setup the assumptions  and assertations in a single place. </p> <p>Another great feature of Mongo is  the Gridfs support. For those home-use cloud applications it is a simple alternative of AWS S3 storage service.</p> <p>Next we will create a simple upload and download endpoint to store binary data into Mongo Gridfs storage and retrieve it from the Gridfs storage.</p> <p>Firstly declare a  <code>GridFSBucket</code> bean.</p> <pre><code>@Factory\npublic class GridFSConfig {\n\n    @Bean\n    GridFSBucket gridFSBucket(MongoClient client) {\n        return GridFSBuckets.create(client.getDatabase(\"photos\"))\n                .withChunkSizeBytes(4096)\n                //.withReadConcern(ReadConcern.MAJORITY)\n                .withWriteConcern(WriteConcern.MAJORITY);\n    }\n}\n</code></pre> <p>Now create a controller to handle the file upload and download.</p> <pre><code>@Controller(\"/photos\")\n@RequiredArgsConstructor\n@Slf4j\npublic class PhotoController {\n\n    private final GridFSBucket bucket;\n\n    @Post(uri = \"/\", consumes = {MediaType.MULTIPART_FORM_DATA})\n    public Mono&lt;HttpResponse&lt;?&gt;&gt; upload(StreamingFileUpload file) {\n        var filename = file.getFilename();\n        var name = file.getName();\n        var contentType = file.getContentType();\n        var size = file.getSize();\n        log.debug(\"uploading file...\\n filename:{},\\n name:{},\\n contentType: {},\\n size: {} \", filename, name, contentType, size);\n        var options = new GridFSUploadOptions();\n        contentType.ifPresent(c -&gt; options.metadata(new Document(\"contentType\", c)));\n        return Mono.from(this.bucket.uploadFromPublisher(\n                                filename,\n                                Mono.from(file).mapNotNull(partData -&gt; {\n                                    try {\n                                        return partData.getByteBuffer();\n                                    } catch (IOException e) {\n                                        e.printStackTrace();\n                                    }\n                                    return null;\n                                }),\n                                options\n                        )\n                )\n                .map(ObjectId::toHexString)\n                .map(id -&gt; ok(Map.of(\"id\", id)));\n    }\n\n    @Get(uri = \"/{id}\", produces = {MediaType.APPLICATION_OCTET_STREAM})\n    public Mono&lt;HttpResponse&lt;?&gt;&gt; download(@PathVariable ObjectId id) {\n        return Mono.from(this.bucket.downloadToPublisher(id))\n                .map(HttpResponse::ok);\n    }\n\n    @Delete(uri = \"/{id}\")\n    public Mono&lt;HttpResponse&lt;?&gt;&gt; delete(@PathVariable ObjectId id) {\n        return Mono.from(this.bucket.delete(id))\n                .map(v -&gt; noContent());\n    }\n}\n\n</code></pre> <p>To upload a file, use <code>bucket.uploadFromPublisher</code> to transfer the upload data into a Gridfs bucket. To download a file, call <code>downloadToPublisher</code> to read data info a <code>ByteBuffer</code>. To remove it, just invoke the delete method.</p> <p>Get the complete source codes from my Github.</p>"},{"location":"gs/prerequisites/","title":"Prerequisites","text":"<p>Before building a Micronaut application, you have to set up your development environment. </p> <p>Ensure you have installed the following softwares.</p> <ul> <li>JDK 17 </li> <li>Gradle or Maven </li> <li>Docker </li> <li>A text editor or IDE, eg. VSCode, Intellij IDEA Community/Ultimate, NetBeans, Eclipse with JEE bundle.</li> </ul>"},{"location":"gs/r2dbc-kotlin-co/","title":"Building RESTful API with Micronaut Data R2dbc and Kotlin Coroutines","text":"<p>In this post, we will continue to explore Micronaut Data  R2dbc,  and rewrite the previous Data Jdbc/Kotlin example with Data R2dbc and Kotlin Coroutines. In contrast to Jdbc, R2dbc is another RDBMS database connection specification but provides asynchronous none-blocking API for users. R2dbc API is totally compatible with Reactive Streams specification. Kotlin Coroutines is an official Kotlin extension provides an event-loop based asynchronous programming model.</p>"},{"location":"gs/r2dbc-kotlin-co/#getting-started","title":"Getting Started","text":"<p>Open your browser and navigate to Micronaut Launch to generate a new project skeleton for this post. Select the following items on this page.</p> <ul> <li> <p>Java version:  17</p> </li> <li> <p>Language: Kotlin </p> </li> <li> <p>Build tool: Gradle Kotlin</p> </li> <li> <p>Test framework: Kotest</p> </li> <li> <p>Included Features: data-r2dbc, postgres, kotlin-extension-functions etc.</p> </li> </ul> <p>Click GENERATE PROJECT button to generate a project archive, download it and extract the files into disk, and import to your IDE, such as IDEA.</p> <p>Open pom.xml file, add Kotlin Coroutines into the project dependencies.</p> <pre><code>//kotlin coroutines\nimplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core\")\nimplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-reactor\")\n</code></pre> <p>The <code>kotlinx-coroutines-reactor</code> provides exchanges between the Reactor API and  Kotlin Coroutines API.</p> <p>Create an Entity mapped to a table in the database.</p> <pre><code>@MappedEntity(value = \"posts\", namingStrategy = NamingStrategies.UnderScoreSeparatedLowerCase::class)\ndata class Post(\n    @AutoPopulated//generated value UUID does not work here.\n    @field:Id var id: UUID? = null,\n    var title: String,\n    var content: String,\n    var status: Status? = Status.DRAFT,\n    @field:DateCreated var createdAt: LocalDateTime? = LocalDateTime.now()\n)\n</code></pre> <p>Micronaut Data R2dbc does not include a <code>UUID</code>  ID generator strategy, here we use <code>@AutoPopulated</code> to generate a random UUID before persisting into database.</p> <p>Create a Repository interface for <code>Post</code> entity.</p> <pre><code>@R2dbcRepository(dialect = Dialect.POSTGRES)\ninterface PostRepository : CoroutineCrudRepository&lt;Post, UUID&gt;, CoroutineJpaSpecificationExecutor&lt;Post&gt;\n</code></pre> <p>Micronaut Data provides several Repository interface for ReactiveStreams API, for Reactor users, there is <code>ReactorCrudRepository</code>. The  <code>CoroutineCrudRepository</code> is a Kotlin Coroutines compatible Repository interface which returns a suspend result in the functions. </p> <p>The <code>@R2dbcRepository</code> requires a <code>dialect</code> here, else it will fail at the application startup.</p> <p>Similarly, <code>JpaSpecificationExecutor</code> has some variants for Reactive Streams, the <code>CoroutineJpaSpecificationExecutor</code> is ready for Kotlin Coroutines. We have created a <code>Specificaitons</code> to setup several criteria for query, update and delete operations, we will reuse them in this post.</p> <p>Let's move to the Controller, create a new controller class named  <code>PostController</code>.</p> <pre><code>@Controller(\"/posts\")\nclass PostController(private val posts: PostRepository) {\n\n    @Get(uri = \"/\", produces = [MediaType.APPLICATION_JSON])\n    fun all(): HttpResponse&lt;Flow&lt;Post&gt;&gt; = ok(posts.findAll())\n\n    @Get(uri = \"/{id}\", produces = [MediaType.APPLICATION_JSON])\n    suspend fun byId(@PathVariable id: UUID): HttpResponse&lt;Any&gt; {\n        val post = posts.findById(id) ?: return notFound()\n        return ok(post)\n    }\n\n    @io.micronaut.http.annotation.Post(consumes = [MediaType.APPLICATION_JSON])\n    suspend fun create(@Body body: Post): HttpResponse&lt;Any&gt; {\n        val saved = posts.save(body)\n        return created(URI.create(\"/posts/\" + saved.id))\n    }\n}\n</code></pre> <p>It looks very similar to  Jdbc version we have done in the last post, but here we return a Kotlin Coroutines specific <code>Flow</code> type or use a <code>suspend</code> function. The difference is all of these methods are executed in an coroutine context.</p> <p>Now let's try to add some sample data via a <code>DataInitializer</code> bean,which listens to a <code>ServerStartUpEvent</code>.</p> <pre><code>@Singleton\nclass DataInitializer(private val posts: PostRepository) {\n\n    @EventListener//does not support `suspend`\n    fun onStartUp(e: ServerStartupEvent) {\n        log.info(\"starting data initialization at StartUpEvent: $e\")\n\n        runBlocking {\n            val deleteAll = posts.deleteAll()\n            log.info(\"deleted posts: $deleteAll\")\n\n            val data = listOf(\n                Post(title = \"Building Restful APIs with Micronaut and Kotlin Coroutine\", content = \"test\"),\n                Post(title = \"Building Restful APIs with Micronaut and Kotlin Coroutine: part 2\", content = \"test\")\n            )\n            data.forEach { log.debug(\"saving: $it\") }\n            posts.saveAll(data)\n                .onEach { log.debug(\"saved post: $it\") }\n                .onCompletion { log.debug(\"completed.\") }\n                .flowOn(Dispatchers.IO)\n                .launchIn(this);\n        }\n\n        log.info(\"data initialization is done...\")\n    }\n\n    companion object DataInitializer {\n        private val log = LoggerFactory.getLogger(DataInitializer::class.java)\n    }\n\n}\n</code></pre> <p>The <code>EventListener</code> does not support a <code>suspend</code> function, use a <code>runBlocking</code> to block the current thread and run the suspend functions in sequence.</p>"},{"location":"gs/r2dbc-kotlin-co/#jpa-criteria-api","title":"JPA Criteria API","text":"<p>Micronaut Data provides JPA criteria API support for both Data Jdbc and Data R2dbc, and also add some <code>JpaSpecificationExecutor</code> variants for Reactive Streams API, as mentioned in previous sections, there is a <code>CoroutineJpaSpecificationExecutor</code> for Kotlin Coroutines.</p> <p>Add <code>jakarta-persistence-api</code> into dependencies to provide JPA Criteria API.</p> <pre><code>implementation(\"jakarta.persistence:jakarta.persistence-api:3.0.0\")\n</code></pre> <p>Let's reuse <code>Specifications</code> we have created in the last post.</p> <p>Create a test to verify the criteria defined in the <code>Specifications</code>.</p> <pre><code>@MicronautTest(environments = [Environment.TEST], startApplication = false)\nclass PostRepositoryTest(\n    private val posts: PostRepository,\n    private val template: R2dbcOperations\n) : StringSpec({\n\n    \"save and find posts\" {\n        val sql = \"insert into posts(title, content, status) values ($1, $2, $3)\";\n        Mono\n            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;\n                Mono.from(\n                    status.connection.createStatement(sql)\n                        .bind(0, \"test title\")\n                        .bind(1, \"test content\")\n                        .bind(2, \"DRAFT\")\n                        .execute()\n                ).flatMap { Mono.from(it.rowsUpdated) }\n            })\n            .log()\n            .`as` { StepVerifier.create(it) }\n            .consumeNextWith { it shouldBeEqualComparingTo 1 }\n            .verifyComplete()\n\n        runBlocking {\n            val all = posts.findAll().toList()\n            all shouldHaveSize 1\n            log.debug(\"all posts: $all\")\n            all.map { it.title }.forAny { it shouldContain \"test\" }\n        }\n\n    }\n\n    \"find by title\" {\n        val sql = \"insert into posts(title, content, status) values ($1, $2, $3)\";\n        Mono\n            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;\n                Mono.from(\n                    status.connection.createStatement(sql)\n                        .bind(0, \"test title\")\n                        .bind(1, \"test content\")\n                        .bind(2, \"DRAFT\")\n                        .execute()\n                ).flatMap { Mono.from(it.rowsUpdated) }\n            })\n            .`as` { StepVerifier.create(it) }\n            .consumeNextWith { it shouldBeEqualComparingTo 1 }\n            .verifyComplete()\n\n        runBlocking {\n            val all = posts.findAll(Specifications.titleLike(\"test\")).toList()\n            log.debug(\"all posts size:{}\", all.size)\n            all shouldHaveSize 1\n\n            val all2 = posts.findAll(Specifications.titleLike(\"test2\")).toList()\n            log.debug(\"all2 posts size:{}\", all2.size)\n            all2 shouldHaveSize 0\n        }\n\n    }\n\n    \"find by keyword\" {\n        val sql = \"insert into posts(title, content, status) values ($1, $2, $3)\";\n        Flux\n            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;\n                val statement = status.connection.createStatement(sql)\n                statement\n                    .bind(0, \"test title\")\n                    .bind(1, \"test content\")\n                    .bind(2, \"DRAFT\")\n                    .add()\n                statement.bind(0, \"test2 title\")\n                    .bind(1, \"test2 content\")\n                    .bind(2, \"DRAFT\")\n                    .add()\n\n                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }\n            })\n            .`as` { StepVerifier.create(it) }\n            .consumeNextWith { it shouldBeEqualComparingTo 1 }\n            .consumeNextWith { it shouldBeEqualComparingTo 1 }\n            .verifyComplete()\n\n        runBlocking {\n            val all = posts.findAll(Specifications.byKeyword(\"test\")).toList()\n            log.debug(\"all posts size:{}\", all.size)\n            all shouldHaveSize 2\n\n            val all2 = posts.findAll(Specifications.byKeyword(\"test2\")).toList()\n            log.debug(\"all2 posts size:{}\", all2.size)\n            all2 shouldHaveSize 1\n        }\n    }\n\n    \"update posts\" {\n        val sql = \"insert into posts(title, content, status) values ($1, $2, $3)\";\n        Flux\n            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;\n                val statement = status.connection.createStatement(sql)\n                statement\n                    .bind(0, \"test title\")\n                    .bind(1, \"test content\")\n                    .bind(2, \"PENDING_MODERATED\")\n                    .add()\n\n                statement\n                    .bind(0, \"test2 title\")\n                    .bind(1, \"test2 content\")\n                    .bind(2, \"PENDING_MODERATED\")\n                    .add()\n\n                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }\n            })\n            .`as` { StepVerifier.create(it) }\n            .consumeNextWith { it shouldBeEqualComparingTo 1 }\n            .consumeNextWith { it shouldBeEqualComparingTo 1 }\n            .verifyComplete()\n\n        runBlocking {\n            val updated = posts.updateAll(Specifications.rejectAllPendingModerated())\n            log.debug(\"updated posts size:{}\", updated)\n            updated shouldBe 2\n\n            val all = posts.findAll().toList()\n            all shouldHaveSize 2\n            all.map { it.status }.forAny { it shouldBe Status.REJECTED }\n        }\n    }\n\n    \"remove posts\" {\n        val sql = \"insert into posts(title, content, status) values ($1, $2, $3)\";\n        Flux\n            .from(template.withTransaction { status: ReactiveTransactionStatus&lt;Connection&gt; -&gt;\n                val statement = status.connection.createStatement(sql)\n                statement\n                    .bind(0, \"test title\")\n                    .bind(1, \"test content\")\n                    .bind(2, \"REJECTED\")\n                    .add()\n                statement\n                    .bind(0, \"test2 title\")\n                    .bind(1, \"test2 content\")\n                    .bind(2, \"DRAFT\")\n                    .add()\n\n                Flux.from(statement.execute()).flatMap { Flux.from(it.rowsUpdated) }\n            })\n            .`as` { StepVerifier.create(it) }\n            .consumeNextWith { it shouldBeEqualComparingTo 1 }\n            .consumeNextWith { it shouldBeEqualComparingTo 1 }\n            .verifyComplete()\n\n        runBlocking {\n            val deleted = posts.deleteAll(Specifications.removeAllRejected())\n            log.debug(\"deleted posts size:{}\", deleted)\n            deleted shouldBe 1\n\n            val all = posts.findAll().toList()\n            all shouldHaveSize 1\n            all.map { it.status }.forAny { it shouldBe Status.DRAFT }\n        }\n    }\n\n}) {\n    companion object {\n        private val log: Logger = LoggerFactory.getLogger(PostRepositoryTest::class.java)\n    }\n\n    override fun beforeEach(testCase: TestCase) {\n        val sql = \"delete from posts\";\n\n        val latch = CountDownLatch(1)\n        Mono\n            .from(\n                this.template.withConnection { conn: Connection -&gt;\n                    Mono.from(conn.beginTransaction())\n                        .then(Mono.from(conn.createStatement(sql).execute())\n                            .flatMap { Mono.from(it.rowsUpdated) }\n                            .doOnNext { log.debug(\"deleted rows: $it \") }\n                        )\n                        .then(Mono.from(conn.commitTransaction()))\n                        .doOnError { Mono.from(conn.rollbackTransaction()).then() }\n                }\n            )\n            .log()\n            .doOnTerminate { latch.countDown() }\n            .subscribe(\n                { data -&gt; log.debug(\"deleted posts: $data \") },\n                { error -&gt; log.error(\"error of cleaning posts: $error\") },\n                { log.info(\"done\") }\n            )\n\n        latch.await(5000, TimeUnit.MILLISECONDS)\n    }\n}\n</code></pre> <p>We converted the existing Jdbc version to R2dbc, there are some mainly difference.</p> <ul> <li>Similar to the blocking <code>TransactionOperations</code>, <code>R2dbcOperations</code> provides <code>withConnection</code> and <code>withTransaction</code> to wrap data operations within a connection or transaction boundary.</li> <li>R2dbc <code>Connection</code> is based on ReactiveStreams API.</li> <li>When binding parameters to the SQL statement, the parameter indices start with 0.</li> <li>The SQL parameter placeholders are dependent on the database itself, for example, Postgres use <code>$1</code>, <code>$2</code>...</li> </ul>"},{"location":"gs/r2dbc-kotlin-co/#testing-controller","title":"Testing Controller","text":"<p>In this post, we still use Kotest as testing framework, as you see in the above <code>PostRepositoryTest</code>,  we use a <code>runBlocking</code> to wrap the coroutines execution in a blocking context.</p> <p>The <code>kotlinx-coroutines-test</code> provides some helpers to simplify the testing of Kotlin Coroutines, eg. <code>runBlockingTest</code>, etc. Add <code>kotlinx-coroutines-test</code> into the test dependencies.</p> <pre><code>//gradle.properties\nkotlinCoVersion=1.6.0-RC\n\n//build.gradle.kt\nval kotlinCoVersion=project.properties.get(\"kotlinCoVersoin\")\n\n//update versions of kotlin coroutines\nimplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:${kotlinCoVersion}\")\nimplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${kotlinCoVersion}\")\n\ntestImplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-test:${kotlinCoVersion}\")\n</code></pre> <p>There is an issue to use <code>runBlockingTest</code> in a test, make sure you are using the latest 1.6.0-RC, and use <code>runTest</code> instead.</p> <p>Similar to the <code>runBlocking</code>, you can use <code>runTest</code> to wrap the testing functionality.</p> <pre><code>@Test\nfun `test GET all posts endpoint with runTest`() = runTest {\n    val response = client.exchange(\"/posts\", Array&lt;Post&gt;::class.java).awaitSingle()\n    response.status shouldBe HttpStatus.OK\n    response.body()!!.map { it.title }.forAny {\n        it shouldContain \"Micronaut\"\n    }\n}\n</code></pre> <p>The <code>runBlockingTest</code> is deprecated in the latest 1.6.0 version of Kotlin Coroutines.</p> <p>We can also mock the repository when testing controllers, as we've done in the previous post. Mockk provides some variants for Kotlin Coroutines, such as <code>coEvery</code>, <code>coVerify</code>, etc.</p> <pre><code>@MicronautTest(environments = [\"mock\"])\nclass PostControllerTest(\n    private val postRepository: PostRepository,\n    @Client(\"/\") private var client: HttpClient\n) : FunSpec({\n\n    test(\"test get posts endpoint\") {\n        val posts = getMock(postRepository)\n        coEvery { posts.findAll() }\n            .returns(\n                flowOf(\n                    Post(\n                        id = UUID.randomUUID(),\n                        title = \"test title\",\n                        content = \"test content\",\n                        status = Status.DRAFT,\n                        createdAt = LocalDateTime.now()\n                    )\n                )\n            )\n        val response = client.toBlocking().exchange(\"/posts\", Array&lt;Post&gt;::class.java)\n\n        response.status shouldBe HttpStatus.OK\n        response.body()!![0].title shouldBe \"test title\"\n\n        coVerify(exactly = 1) { posts.findAll() }\n    }\n}) {\n    @MockBean(PostRepository::class)\n    fun mockedPostRepository() = mockk&lt;PostRepository&gt;()\n}\n\n</code></pre> <p>Firstly, create a mock bean for <code>PostRepository</code> , then do stubbing with a <code>coEvery</code> and verify the calls in the mocks with <code>coVerify</code> clause.</p> <p>Get the complete source codes from my Github.</p>"},{"location":"intro/","title":"Introduction to Micronaut","text":"<p>In this chapter, let's go through the features provided in Mcironaut.</p>"},{"location":"intro/what/","title":"What is Micronaut?","text":"<p>In the homepage of Micronaut, it describes Micronaut is:</p> <p>A modern, JVM-based, full-stack framework for building modular, easily testable microservice and serverless applications.</p> <p>Micronaut is relatedly new to Java developers, and it adopts the good part of the existing frameworks, such as Grails, Spring Boot, etc.</p>"},{"location":"intro/why/","title":"Why Micronaut?","text":"<p>Micronaut developers adopts the good parts from the existing Java frameworks, such as Grails, Spring Boot,Quarkus. So even Micronaut is relatedly young, but it includes powerful and concise APIs for developers.</p> <p>Here we list some highlight features, </p> <ul> <li>The Micronaut Data and controller APIs are similar to Spring Data and Spring WebMvc. For relational database support, Micronaut Data provides more powerful and united annotations to both Jdbc and R2dbc, and it brings the programmatic JPA <code>Specification</code> to Jdbc/R2dbc queries. </li> <li>Great parts of the existing Grails framework, esp. Gorm is available in Micronaut. </li> <li>More testing frameworks and tools support. Besides JUnit, it supports KoTest and Spock officially.</li> <li>More concise application lifecycle event abstract, make it suitable for different application types, from serverless application to general web application.</li> <li>Through Maven plugin or Gradle plugin provides AOT compiling support. The annotations of Dependency Injection, Bean Validation and Jakarta Transaction are processed at compile time instead of dynamic invocation by Java reflection APIs at runtime, which makes it possible to build Micronaut applications into GraalVM native executable binaries. And Redhat Quarkus uses a similar approach to handle CDI beans at compile time. Micronaut and Quarkus affect the next generation CDI specification. There is a new sub specification under CDI named CDI Lite(maybe the naming is not good), which tries to define a united behavior of processing CDI beans at compile time. Check the Eclipse implementation of CDI Lite.</li> </ul>"},{"location":"test/","title":"Testing","text":"<p>Micronaut provides integraion for the popluar testing frameworks, including JUnit, KoTest and Spock.</p>"},{"location":"test/junit/","title":"Testing Micronaut Application with JUnit","text":"<p>JUnit is the most popular testing framework for Java developers. </p>"},{"location":"test/junit/#adding-junit","title":"Adding JUnit","text":"<p>When generating a Micronaut application, make sure you have selected JUnit testing framework.</p> <p>Open build.gradle in the project root.</p> <p>In the micronaut task configuration, there is testRuntime(\"junit5\"), it sets up the junit-jupiter in test scope.</p> <p>AssertJ and Mockito are usually used with JUnit. The former provides fluent asserting APIs, and the later is the defact mocking framework.</p> <p>Add the following into the dependencies block.</p> <pre><code>testImplementation(\"org.assertj:assertj-core\")\ntestImplementation(\"org.mockito:mockito-core\")\n</code></pre>"},{"location":"test/junit/#test-persistence-layer","title":"Test Persistence Layer","text":"<p>Write a test to verify functionality of <code>PostRepository</code>. Similar to the <code>@SpringBootTest</code>, Micronaut provides a <code>@MicronautTest</code>. </p> <pre><code>@MicronautTest(application = Application.class, startApplication = false)\nclass PostRepositoryTest {\n\n    @Inject\n    PostRepository posts;\n\n    @PersistenceContext\n    EntityManager entityManager;\n\n    @Test\n    void testCreatePost() {\n        var entity = Post.builder().title(\"test title\").content(\"test content\").build();\n        this.entityManager.persist(entity);\n\n        assertThat(entity.getId()).isNotNull();\n        assertTrue(posts.findById(entity.getId()).isPresent());\n    }\n\n}\n</code></pre> <p>Here we set <code>startApplication = false</code>, it does not start the embedded server to host the application, to test against the database, we do not need a running application</p> <p>We have add <code>testcontainers</code> feature, it will configure a Postgres for test automatically.  Check the testcontainers config in the <code>src/test/resources/application-test.yml</code>.</p> <pre><code>datasources:\n  default:\n    url: jdbc:tc:postgresql:12:///postgres\n    driverClassName: org.testcontainers.jdbc.ContainerDatabaseDriver\n</code></pre> <p>When there is a <code>tc</code> as database host name, testcontainer will start up a Postgres database automatically.</p>"},{"location":"test/junit/#testing-controller","title":"Testing Controller","text":"<p>Write a test for the <code>PostController</code>. </p> <pre><code>@MicronautTest(environments = Environment.TEST)\npublic class PostControllerTest {\n\n    @Inject\n    @Client(\"/\")\n    HttpClient client;\n\n    @Inject\n    PostRepository posts;\n\n    @Inject\n    CommentRepository comments;\n\n    @MockBean(PostRepository.class)\n    PostRepository posts() {\n        return mock(PostRepository.class);\n    }\n\n    @MockBean(CommentRepository.class)\n    CommentRepository comments() {\n        return mock(CommentRepository.class);\n    }\n\n    @Test\n    @DisplayName(\"test GET '/posts' endpoint\")\n    public void testGetAllPosts() throws Exception {\n        when(this.posts.findAll()).thenReturn(\n                List.of(Post.builder().id(UUID.randomUUID()).title(\"test title\").content(\"test content\").build())\n        );\n        var response = client.toBlocking().exchange(\"/posts\", PostSummaryDto[].class);\n        assertEquals(HttpStatus.OK, response.status());\n        var body = response.body();\n        assertThat(body.length).isEqualTo(1);\n        assertThat(body[0].title()).isEqualTo(\"test title\");\n\n        verify(this.posts, times(1)).findAll();\n        verifyNoMoreInteractions(this.posts);\n    }\n\n    @Test\n    @DisplayName(\"test GET '/posts/{id}' endpoint\")\n    public void testGetSinglePost() throws Exception {\n        when(this.posts.findById(any(UUID.class))).thenReturn(\n                Optional.ofNullable(Post.builder().id(UUID.randomUUID()).title(\"test title\").content(\"test content\").build())\n        );\n        var request = HttpRequest.GET(UriBuilder.of(\"/posts/{id}\").expand(Map.of(\"id\", UUID.randomUUID())));\n        var response = client.toBlocking().exchange(request, PostDetailsDto.class);\n        assertEquals(HttpStatus.OK, response.status());\n        var body = response.body();\n        assertThat(body.title()).isEqualTo(\"test title\");\n\n        verify(this.posts, times(1)).findById(any(UUID.class));\n        verifyNoMoreInteractions(this.posts);\n    }\n\n    @Test\n    @DisplayName(\"test GET '/posts/{id}' endpoint that does not exist\")\n    public void testGetSinglePost_notFound() throws Exception {\n        when(this.posts.findById(any(UUID.class))).thenReturn(Optional.ofNullable(null));\n        var request = HttpRequest.GET(UriBuilder.of(\"/posts/{id}\").expand(Map.of(\"id\", UUID.randomUUID())));\n        var exception = assertThrows(HttpClientResponseException.class, () -&gt; client.toBlocking().exchange(request, PostDetailsDto.class));\n\n        assertEquals(HttpStatus.NOT_FOUND, exception.getStatus());\n        verify(this.posts, times(1)).findById(any(UUID.class));\n        verifyNoMoreInteractions(this.posts);\n    }\n}\n</code></pre> <p>In this test, we use Mockito to mock all dependent beans(<code>PostRepository</code> and <code>CommentRepository</code>) in the <code>PostController</code>.  To mock beans in the test context, Micronaut provides a <code>MockBean</code> to produce a mocked instance to replace the real beans.</p> <p>Similar to Spring's <code>RestTemplate</code> or <code>WebClient</code>,  Micronaut provides a <code>HttpClient</code> to send request to a certain URI, by default it uses the ReactiveStreams compatible API, If you are stick on the traditional blocking API, call the <code>toBlocking()</code> method to switch to use it. </p> <p>The <code>exchange</code> method will return a HTTP response object, and the <code>retrieve</code> method returns the response body directly.</p> <p>Note: When using blocking APIs, if it returns a failure HTTP response, such as return a 4xx status code,  it will throws a <code>HttpClientResponseException</code> instead. In contrast,  in ReactiveStreams APIs, it will emit the exception to error channel.</p>"},{"location":"test/junit/#_1","title":"JUnit","text":""},{"location":"test/junit/#integration-tests","title":"Integration Tests","text":"<p>The following is an example of integration tests, it tries to test all APIs in an integration environment with a real database, and running on a live embedded server.</p> <pre><code>@MicronautTest\n@Slf4j\nclass IntegrationTests {\n\n    @Inject\n    @Client(\"/\")\n    HttpClient client;\n\n    @Inject\n    EmbeddedApplication&lt;?&gt; application;\n\n    @Test\n    void testItWorks() {\n        Assertions.assertTrue(application.isRunning());\n    }\n\n    @Test\n    void testGetAllPosts() {\n        var response = client.exchange(HttpRequest.GET(\"/posts\"), String.class);\n\n        var bodyFlux = Flux.from(response).map(HttpResponse::body);\n        StepVerifier.create(bodyFlux)\n                .consumeNextWith(posts -&gt; assertThat(JsonPath.from(posts).getInt(\"totalSize\")).isGreaterThanOrEqualTo(2))\n                .verifyComplete();\n    }\n\n    @Test\n    public void testCrudFlow() {\n        //create a new post\n        var request = HttpRequest.POST(\"/posts\", new CreatePostCommand(\"test title\", \"test content\"));\n        var blockingHttpClient = client.toBlocking();\n        var response = blockingHttpClient.exchange(request);\n        assertThat(response.status().getCode()).isEqualTo(201);\n        var savedUrl = response.getHeaders().get(\"Location\");\n        assertThat(savedUrl).isNotNull();\n        log.debug(\"saved post url: {}\", savedUrl);\n\n        //get by id\n        var getPostResponse = blockingHttpClient.exchange(savedUrl, Post.class);\n        assertThat(getPostResponse.getStatus().getCode()).isEqualTo(200);\n\n        // add comments\n        var addCommentRequest = HttpRequest.POST(savedUrl + \"/comments\", new CreateCommentCommand(\"test content\"));\n        var addCommentResponse = blockingHttpClient.exchange(addCommentRequest);\n        assertThat(addCommentResponse.getStatus().getCode()).isEqualTo(201);\n        var savedCommentUrl = addCommentResponse.getHeaders().get(\"Location\");\n        assertThat(savedCommentUrl).isNotNull();\n\n        // get all comments\n        var getAllCommentsRequest = HttpRequest.GET(savedUrl + \"/comments\");\n        var getAllCommentsResponse = blockingHttpClient.exchange(getAllCommentsRequest, Argument.listOf(CommentDetailsDto.class));\n        assertThat(getAllCommentsResponse.status().getCode()).isEqualTo(200);\n        assertThat(getAllCommentsResponse.body().size()).isEqualTo(1);\n\n        //delete by id\n        var deletePostResponse = blockingHttpClient.exchange(HttpRequest.DELETE(savedUrl));\n        assertThat(deletePostResponse.getStatus().getCode()).isEqualTo(204);\n\n        //get by id again(404)\n        var e = Assertions.assertThrows(HttpClientResponseException.class, () -&gt;\n                blockingHttpClient.exchange(HttpRequest.GET(savedUrl)));\n        var getPostResponse2 = e.getResponse();\n        assertThat(getPostResponse2.getStatus().getCode()).isEqualTo(404);\n    }\n\n}\n</code></pre> <p>In the <code>testGetAllPosts</code> test, we try to use reactive <code>HttpClient</code> APIs and use reactor-test's <code>StepVerifier</code> to assert the data in a reactive data stream.</p> <p>The second test mothed is verifying the whole flow of creating a post, add comments, fetching comments, and deleting the post. </p> <p>In an API integration tests, test itself works as a Http client(through a HTTP Client library) to interact with the backend with defined APIs. Ideally you can use any HttpClient to test APIs, such as Java 11 HttpClient, OKHttp, etc. There are some examples in the example repository using <code>RestAssured</code> and Java 11 new <code>HttpClient</code>, check the source codes and explore them yourself.</p>"},{"location":"test/kotest/","title":"Testing Micronaut Application with Kotest","text":""},{"location":"test/spock/","title":"Testing Micronaut Application with Spock framework","text":""}]}